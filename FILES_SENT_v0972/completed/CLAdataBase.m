classdef CLAdataBase
    % CLAdataBase
    %   
    % Detailed explanation goes here
    %
    % -------------------------------------------------------------

    properties


        Description             % A string or char description of the 
                                % database


        LoanDataTable           % A CLAdataTable class ojbect holding the 
                                % Loan level data

        FacilitiesDataTable     % A CLAdataTable class object holding the 
                                % Facilities level data
                                % Fields must include:
                                %   - 

        BorrowerVariableDataTable % A CLAdataTable class object 
                                  % holding the Borrower level data
                                  % Fields must include:
                                  %   - 

        BorrowerStaticDataTable   % A CLAdataTable class object 
                                  % holding the Borrower level data
                                  % Fields must include:
                                  %   - 

        AvailableFileDates  % A list (vector) of unique file dates
                            % (dates on which the data were 
                            % assembled and delivered)

        Importer            % The importer (with much of the data removed 
                            % for space) but will hold the locations of the
                            % files that hold the raw imported data.


        TaxonomyTabs        % TaxonomyTabs is a data structure holding 
                            % MATLAB tables.  Each table must be named with 
                            % a variable held in VariableNames. All tables 
                            % in the structure must:
                            % (1) have only two variables, one with the 
                            % variable ID (named VariableNameID) and the 
                            % other with the translation of the variable ID
                            % to a categorical variable.
                            % (2) IDs must be numeric and be limited to the
                            % numbers held in the DataMat under the
                            % variable named in the table

         H                  % Historical table generated by gimmeCleanHist 
                            % holding the historical data. If generated by 
                            % gimmeCleanHist, also is cleaned and holds
                            % certain transformed fields.


    end

    methods
        function DB = CLAdataBase(LoanDataTable, FacilitiesDataTable, ...
                BorrowerVariableDataTable, BorrowerStaticDataTable)
            % CLAdataBase
            %   
            % Build an instance of a CLAdataBase class object
            %
            % -------------------------------------------------------------

            % Set Data Table Properties
            DB.LoanDataTable = LoanDataTable;
            DB.FacilitiesDataTable = FacilitiesDataTable;
            DB.BorrowerVariableDataTable = BorrowerVariableDataTable;
            DB.BorrowerStaticDataTable = BorrowerStaticDataTable;

            % Set AvailableFileDates property (a full list of all
            % available File Dates). Note that static data does
            % not have processing date keys (because it is static), so we
            % do not need to pull out the dates from 
            % BorrowerStaticDataTable
            DB.AvailableFileDates = getFileDates(LoanDataTable,FacilitiesDataTable,BorrowerVariableDataTable);

            % Create TaxonomyTabs data structure (concatenation of each of
            % the individual TaxonomyTabs data structures from the database
            % components
            TT = struct();
            fieldnamesl = fieldnames(LoanDataTable.TaxonomyTabs);

            for l = 1:length(fieldnamesl)
                fn = fieldnamesl{l};
                TT.(char(fn)) = LoanDataTable.TaxonomyTabs.(char(fn));
            end

            fieldnamesf = fieldnames(FacilitiesDataTable.TaxonomyTabs);
            for f = 1:length(fieldnamesf)
                fn = fieldnamesf{f};
                TT.(char(fn)) = FacilitiesDataTable.TaxonomyTabs.(char(fn));
            end


            fieldnamesb = fieldnames(BorrowerVariableDataTable.TaxonomyTabs);
            for b = 1:length(fieldnamesb)
                fn = fieldnamesb{b};
                TT.(char(fn)) = BorrowerVariableDataTable.TaxonomyTabs.(char(fn));
            end

            fieldnamess = fieldnames(BorrowerStaticDataTable.TaxonomyTabs);
            for s = 1:length(fieldnamess)
                fn = fieldnamess{s};
                TT.(char(fn)) = BorrowerStaticDataTable.TaxonomyTabs.(char(fn));
            end

            DB.TaxonomyTabs = TT;

        end

        function DB = updateDB(DB,IMP)
            %
            %   UPDATE
            %
            %
            %
            %
            % -------------------------------------------------------------


            % VARIABLE DATA -----------------------------------------------
            % Variable data is updated on a month by month basis. So each
            % month comes in from either the input data or the existing
            % data (it cannot be mixed).

            % Set Import Files
            LOANDataTable = IMP.LOAN_updt;
            FACILITIESDataTable = IMP.FACILITIES_updt;
            BORROWERVariableDataTable = IMP.BORROWERV_updt;
            BORROWERStaticDataTable = IMP.BORROWERS_updt;
            Overwrite = IMP.Overwrite;

            % Get UpdtFileDates
            % Find New Dates for Dated data. If the user selected to
            % overwrite, the update file dates will be the same as the New
            % File Dates. Otherwise, the update file dates will only be the
            % file dates that do not currently have data in the database.
            NewFileDates = getFileDates(LOANDataTable,FACILITIESDataTable,BORROWERVariableDataTable);
            CurFileDates = DB.AvailableFileDates;

            if Overwrite
                UpdtFileDates = NewFileDates;
            else
                idx_newFDonly = ~ismember(NewFileDates,CurFileDates);
                UpdtFileDates = NewFileDates(idx_newFDonly);
            end

            % Update Facilities Data
            facilitiesDatatoAdd = FACILITIESDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            assignin("base","facilitiesDatatoAdd",facilitiesDatatoAdd)
            assignin("base","datamat",DB.FacilitiesDataTable.DataMat)
            DB.FacilitiesDataTable.DataMat = [DB.FacilitiesDataTable.DataMat;facilitiesDatatoAdd];
            

            % Update Loan Data
            loanDatatoAdd = LOANDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            DB.LoanDataTable.DataMat = [DB.LoanDataTable.DataMat; loanDatatoAdd];

            % Update Borrower Variable Data
            borrowervDatatoAdd = BORROWERVariableDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            DB.BorrowerVariableDataTable.DataMat = [DB.BorrowerVariableDataTable.DataMat; borrowervDatatoAdd];


            % AvailableFileDates PROPERTY ---------------------------------
            % Once we have changed the variable data (added file dates), we
            % need to update the AvailableFileDates property to reflect the
            % additional file dates
            DB.AvailableFileDates = getFileDates(DB.LoanDataTable,...
                DB.FacilitiesDataTable,DB.BorrowerVariableDataTable);


            % STATIC DATA -------------------------------------------------
            % The borrower static data does not change from month to month,
            % so (depending on if we are overwriting) we only identify 
            % borrowers that do not exist in the current borrower static 
            % data. Everything is keyed off of borrower_ID

            % Get UpdtBIDs
            % Identify the borrower IDs that we will be updating
            newBIDs = BORROWERStaticDataTable.GimmeCLAmatrix("borrower_ID");
            curBIDs = DB.BorrowerStaticDataTable.GimmeCLAmatrix("borrower_ID");

            if Overwrite
                updBIDs = newBIDs;
            else
                idx_newBIDonly = ~ismember(newBIDs,curBIDs);
                updBIDs = newBIDs(idx_newBIDonly);
            end

            idx_BDtoAdd = ismember(BORROWERStaticDataTable.GimmeCLAmatrix("borrower_ID"),updBIDs);
            BDtoAdd = BORROWERStaticDataTable.DataMat(idx_BDtoAdd,:);
            DB.BorrowerStaticDataTable.DataMat = [DB.BorrowerStaticDataTable.DataMat;BDtoAdd];




        end

        function [DB,clean_diagnostics] = gimmeCleanHist(DB,YearTreasury,varargin)
            %
            %
            %
            %
            %


            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % YearTreasury


            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;

            % Calcualte Single Pricing IDs
            %[TAB,SPIDdups] = GimmeCLAHistTab(DB);



            % Get the untransformed, uncleaned historical data
            H = GimmeCLAHistTab(DB);
            
            %% TERM (IN MONTHS)
            % Remove facility data with NaN Effective Date, or NaN Maturity
            % Date, or Effective Date greater than Maturity Date
            
            % Calculate the Term
            H.TermMonths = split(between(...
                datetime(H.F_Facility_Effective_Date,'ConvertFrom','datenum'),...
                datetime(H.F_Facility_Maturity_Date,'ConvertFrom','datenum'),...
                'months'),'months');

            % Create Estimated Term Field
            H.Term_Estimated = H.TermMonths;
            H.Term_Estimated(isnan(H.Term_Estimated)) = mode(H.TermMonths(H.TermMonths>3));


            % Identify Negative or NaN term
            if strcmpi(termtype,'estimated')
                fprintf('cleanhist estimated.\n')
                idx_NegativeOrNaNTerm = or(isnan(H.Term_Estimated),H.Term_Estimated<1);
            else
                idx_NegativeOrNaNTerm = or(isnan(H.TermMonths),H.TermMonths<1);
            end

            clean_diagnostics.BadLoanData_BadTerm = H(idx_NegativeOrNaNTerm,:);
            clean_diagnostics.BadLoanData_BadTerm.Properties.Description = ...
                ['Facility data with errors in the term, either NaN effective date, ' ...
                'maturity date or negative term.'];
            
            % Clean Data
            % if term is less than zero, we set term to NaN (which will cause the
            % distance along the term dimension to be set to 1 (maximum)).
            H.TermMonths(idx_NegativeOrNaNTerm) = NaN;
                        
            % If term is greater than 30 years (360 months), remove the loan
            idx_TermMoreThan30years = H.TermMonths > 360;
            clean_diagnostics.TermMoreThan30Years = H(idx_TermMoreThan30years,:);
            H = H(~idx_TermMoreThan30years,:);
            
            
            %% LOAN SIZE
            % Loans with a commitment amount greater than 250MM will be excluded from
            % the data set
            idx_CommitOver250MM = H.F_Commitment_Amount > 250000000;
            clean_diagnostics.CommitOver250MM = H(idx_CommitOver250MM,:);
            H = H(~idx_CommitOver250MM,:);
            
            %% Pricing (NaN Pricing)
            % Remove fixed rate loans with NaN fixed rate, and remove floating rate
            % loans with NaN spreads
            idx_FixRateNaNRate = and(H.L_pricing_structure == 1, isnan(H.L_interest_rate_percent));
            clean_diagnostics.FixRateNanRate = H(idx_FixRateNaNRate,:);
            H = H(~idx_FixRateNaNRate,:);
            
            idx_FlRateNaNSpr = and(H.L_pricing_structure == 2, isnan(H.L_spread_bps));
            clean_diagnostics.FlRateNaNSpr = H(idx_FlRateNaNSpr,:);
            H = H(~idx_FlRateNaNSpr,:);
            
            %% Remove Obvioiusly Illegal Pricing
            % Spreads of more than 50% removed
            idx_illegal = or(and(H.L_pricing_structure == 2,H.L_spread_bps>5000),...
                and(H.L_pricing_structure == 1,H.L_interest_rate_percent>50));
            clean_diagnostics.ObviouslyIllegal = H(idx_illegal,:);
            H = H(~idx_illegal,:);
            
            %% Remove 0 Fixed Rates
            idx_zeroFixed = and(H.L_pricing_structure == 1, H.L_interest_rate_percent<0.00001);
            clean_diagnostics.ZeroFixed = H(idx_zeroFixed,:);
            H = H(~idx_zeroFixed,:);
            
            
            %% PRICING (off Market)
            % From Ryan: It looks like Fifth Third (bank 3), Business Banking (LOB 8), 
            % Term Loans (Loan Type 2) are the large majority of rates under 5% (an 
            % approximation of the 1 Year Treasury for 2023). Without this population, 
            % the number of low rates decreases drastically.
            %
            % Any loans with Bank_ID == 3, Line_of_Business == 8, AND Loan_Type ==2
            % will be considered excluded from the IQR range, but will be included in
            % the data set as long as it survives the other tests.
            %
            % All loans in a facility that includes the pricing fallilng outside of the
            % IQR will be removed.  This is for two reasons (1) practical: we cannot use
            % the loanID since loan IDs are not unique across banks, and (2) it is
            % reasonable to belive that other pricing within a faciilty may be off
            % market to either "make up" for artificially low spreads, or if one is
            % erroneous, others may be too.
            
            % Add field to H table indicating whether the loan will be inclueed in the
            % IQR calculation
            idx_FifthThird = H.L_Bank_ID == 3;
            idx_LOB = H.L_Line_of_Business == 8;
            idx_Term = H.L_Loan_Type == 2;
            idx_notInIQR  = all([idx_FifthThird,idx_LOB,idx_Term],2);
            clean_diagnostics.excludedFromIQR = H(idx_notInIQR,:);
            H.notInIQR = idx_notInIQR;
            fprintf("%.0f loans marked outside of IQR calculation.\n",sum(H.notInIQR))
            
                        
            %% Idenfity Likely Outliers (using IQR)
            % Loop through each month and calculate the monthly IQR (excluding non-IQR
            % data), then identify all of the loans (using Loan Price ID) that will be
            % removed for being more than the threshold IQRs from the mean.
            fdsavailable = DB.AvailableFileDates;
            badSprSOFRFids = [];
            badSprPRIMEFids = [];
            badFixedFids = [];
            
            
            for m = 1:length(fdsavailable)
                mth = fdsavailable(m);
                M = H(H.L_file_date == mth,:);
            
                % Set up plot
                %figure('Position',[100 100 1070 500])
            
                %%% SPREADS to SOFR
                idx_SOFR = and(and(M.L_Index>=103,M.L_Index<=109),M.L_pricing_structure == 2); 
                MFL_SOFR = M(idx_SOFR,:);
                [r_spr,q_spr] = iqr(MFL_SOFR.L_spread_bps(~MFL_SOFR.notInIQR),"all");
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*1.5;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_SOFR.L_spread_bps>maxSPR;
                idx_SPRtooLow_m = MFL_SOFR.L_spread_bps<minSPR;
                badSprSOFRFids = [badSprSOFRFids;MFL_SOFR.L_Facility_ID(idx_SPRtooHigh_m);MFL_SOFR.L_Facility_ID(idx_SPRtooLow_m)];
                
                %subplot(1,3,1)
                %h = histogram(MFL_SOFR.L_spread_bps);
                %tit = sprintf('Spreads to SOFR\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %binwidth = h.BinWidth;
                %hold on
                %idx_excludeSPR = ismember(MFL_SOFR.L_Facility_ID,badSprSOFRFids);
                %histogram(MFL_SOFR.L_spread_bps(~idx_excludeSPR),'BinWidth',binwidth)
                %tit = sprintf('Spreads to SOFR\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %legend({'All Observations','Excluding Outliers'},...
                %    'Location','southoutside')
                %hold off
            
            
                %%% SPREADS to PRIME
                idx_PRIME = and(and(M.L_Index>=10,M.L_Index<=14),M.L_pricing_structure == 2); 
                MFL_PRIME = M(idx_PRIME,:);
                [r_spr,q_spr] = iqr(MFL_PRIME.L_spread_bps(~MFL_PRIME.notInIQR),"all");
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*nIQRs;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_PRIME.L_spread_bps>maxSPR;
                idx_SPRtooLow_m = MFL_PRIME.L_spread_bps<minSPR;
                badSprPRIMEFids = [badSprPRIMEFids;MFL_PRIME.L_Facility_ID(idx_SPRtooHigh_m);MFL_PRIME.L_Facility_ID(idx_SPRtooLow_m)];
            
                %subplot(1,3,2)
                %h = histogram(MFL_PRIME.L_spread_bps);
                %binwidth = h.BinWidth;
                %tit = sprintf('Spread to PRIME\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %hold on
                %idx_excludeSPRPRIME = ismember(MFL_PRIME.L_Facility_ID,badSprPRIMEFids);
                %histogram(MFL_PRIME.L_spread_bps(~idx_excludeSPRPRIME),'BinWidth',binwidth);
                %legend({'All Observations','Excluding Outliers'},...
                %    'Location','southoutside')
                %hold off
            
            
                %%% FIXED RATES
                MFX = M(M.L_pricing_structure == 1,:);
                [r_fix,q_fix] = iqr(MFX.L_interest_rate_percent(~MFX.notInIQR),"all");
                nIQRs = 1;
                maxFIX = q_fix(2)+r_fix*nIQRs;
                minFIX = q_fix(1)-r_fix*nIQRs;
                idx_FIXtooHigh_m = MFX.L_interest_rate_percent>maxFIX;
                idx_FIXtooLow_m = MFX.L_interest_rate_percent<minFIX;
                badFixedFids = [badFixedFids;MFX.L_Facility_ID(idx_FIXtooHigh_m);MFX.L_Facility_ID(idx_FIXtooLow_m)];
            
                % Hard limit using treasuries
                Tmonth = mean(YearTreasury.DGS1(YearTreasury.MONTH == mth));
                TmonthMin = 0.75 .* Tmonth;
            
                %subplot(1,3,3)
                %h = histogram(MFX.L_interest_rate_percent);
                %binwidth = h.BinWidth;
                %tit = sprintf('Fixed Rate\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %hold on
                
                idx_excludeFIX = ismember(MFX.L_Facility_ID,badFixedFids);

                %histogram(MFX.L_interest_rate_percent(~idx_excludeFIX),'BinWidth',binwidth)
                %tit = sprintf('Fixed Rate\n(IQR: %.4f, Max: %.2f, Min: %.2f)\n%s',...
                %    (q_fix(2) - q_fix(1)),maxFIX, minFIX,strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                % 
                %hold on
                %yl = ylim();
                %plot([TmonthMin,TmonthMin],[0,yl(2)])
                %legend({'All Observations','Excluding Outliers','.75 of US Treasury (1year)'},...
                %    'Location','southoutside')
                %hold off
            
            
                
            end
            
            idx_badSpreads = ismember(H.PriceDecisionID,badSprSOFRFids);
            clean_diagnostics.SPRtooHighOrtooLow = H(idx_badSpreads,:);
            H = H(~idx_badSpreads,:);
            
            idx_badFixed = ismember(H.PriceDecisionID,badFixedFids);
            clean_diagnostics.FIXtooHighortooLow = H(idx_badFixed,:);
            H = H(~idx_badFixed,:);

            %% Set DB.H Property
            DB.H = H;







        end
        
        function DB = swapToLIBOR(DB,SI,varargin)
            % SwapToLibor
            %
            % Swaps fixed rate loans to LIBOR (in Loans Table)
            % Stores unswapped rate as UnswappedSPR
            %
            %
            % 

            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;   


            % Check that the swap Importer has a Libor Table
            if isempty(SI.LIBOR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the swap Importer has a LIBOR Table
            if isempty(SI.LIBOR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the history has been generated
            if isempty(DB.H)
                msg = sprintf('missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n');
                error(msg)
            end

            % Check that history has been cleaned
            if ~ismember('notInIQR',DB.H.Properties.VariableNames)
                msg = sprintf('missing certain historical data fields. Please run gimmeCleanHist then swap.\n');
                error(msg)
            end


            % Set inputs
            SWAPS = SI.LIBOR;
            LOANS = DB.H;


            % Initialize Output Series
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);
          

            for l = 1:size(LOANS,1)
            
                % Get the Date of the swap. Start by finding the file date of the loan,
                % then, if that date has swap data, use that date, otherwise, find the
                % closest date.
                loanDate = LOANS.L_file_date(l);
                if ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                else
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                end
            
                % Get the row of the swap (associated with the date)
                idx_swaprow = SWAPS.SWAPDATE == swapdate;
            
                if sum(idx_swaprow) == 1
                
                    % Get the column of the swap table (associated with the swap tenor   
                    % Use the term of the loan to identify Which Swap Series we are Looking 
                    % for
                    if strcmpi(termtype,'estimated')
                        swapvarn = strcat("LIBORSWAP_",num2str(LOANS.Term_Estimated(l)));
                    else
                        swapvarn = strcat("LIBORSWAP_",num2str(LOANS.TermMonths(l)));
                    end
            
                    % If there the swap variable name is valid (term of the loan
                    % reflects a swap value), return the swap rate
                    if ismember(swapvarn,SWAPS.Properties.VariableNames)
                        % Return the swap rate
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    else
                        % bad swap tenor error
                        swapRateERR(l) = swapRateERR(l)+10;
                    end
            
                else
                    % bad swap date error
                    swapRateERR(l) = swapRateERR(l)+1;
                end
            end
            
            % Add Swap Rate to Table
            LOANS.SwapRate_LIBOR =  swapRate;

            % Add Error Series to TAble
            LOANS.SwapErrorKey = swapRateERR;
            
            % Store Unswapped spreads
            LOANS.UnswappedSPR = LOANS.L_spread_bps;
            
            % Store Swapped Spread
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_LIBOR(idx_fixed);
            DB.H = LOANS;

        end

        function DB = swapToSOFR(DB,SI,varargin)
            % SwapToSOFR
            %
            % Swaps fixed rate loans to SOFR (in Loans Table)
            % Stores unswapped rate as UnswappedSPR
            %
            %
            % 


            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;      

            % Check that the swap Importer has a SOFR Table
            if isempty(SI.SOFR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the history has been generated
            if isempty(DB.H)
                msg = sprintf('missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n');
                error(msg)
            end

            % Check that history has been cleaned
            if ~ismember('notInIQR',DB.H.Properties.VariableNames)
                msg = sprintf('missing certain historical data fields. Please run gimmeCleanHist then swap.\n');
                error(msg)
            end



            % Set inputs
            SWAPS = SI.SOFR;
            LOANS = DB.H;


            % Initialize Output Series
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);
            
            
            
            for l = 1:size(LOANS,1)
            
                % Get the Date of the swap. Start by finding the file date of the loan,
                % then, if that date has swap data, use that date, otherwise, find the
                % closest date.
                loanDate = LOANS.L_file_date(l);
                if ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                else
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                end
            
                % Get the row of the swap (associated with the date)
                idx_swaprow = SWAPS.SWAPDATE == swapdate;
            
                if sum(idx_swaprow) == 1
                
                    % Get the column of the swap table (associated with the swap tenor   
                    % Use the term of the loan to identify Which Swap Series we are Looking 
                    % for
                    if strcmpi(termtype,'estimated')
                        swapvarn = strcat("SOFRSWAP_",num2str(LOANS.Term_Estimated(l)));
                    else
                        swapvarn = strcat("SOFRSWAP_",num2str(LOANS.TermMonths(l)));
                    end
            
                    % If there the swap variable name is valid (term of the loan
                    % reflects a swap value), return the swap rate
                    if ismember(swapvarn,SWAPS.Properties.VariableNames)
                        % Return the swap rate
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    else
                        % bad swap tenor error
                        swapRateERR(l) = swapRateERR(l)+10;
                    end
            
                else
                    % bad swap date error
                    swapRateERR(l) = swapRateERR(l)+1;
                end
            end


            % Add Swap Rate to Table
            LOANS.SwapRate_SOFR =  swapRate;

            % Add Error Series to TAble
            LOANS.SwapErrorKey = swapRateERR;
            
            % Store Unswapped spreads
            LOANS.UnswappedSPR = LOANS.L_spread_bps;
            
            % Store Swapped Spread
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_SOFR(idx_fixed);
            DB.H = LOANS;


        end

        function [MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate)
            
            % GimmeCLAMat
            %
            % Returns matrix data from the CLA Database
            % Returns full matrix for a specific filedate
            % FileDate must be in datenumber format
            % 
            % This funciton is the basis for building the table returned in
            % GimmeCLATable.
            %
            % This function is the basis for building the historical matrix
            % and table returned in GimmeCLAHist
            % -------------------------------------------------------------
            diagnostics = struct();

            % Check that File Date is available
            if ~ismember(FileDate,DB.AvailableFileDates)
                msg = sprintf('File date %.0f, not found in list of available dates.\n',FileDate);
                error(msg)
            end
            if numel(FileDate)>1
                msg = sprintf('FileDate must be a single date, not a vector or a range.\n');
                error(msg);
            end

            % VARIABLE DATA -----------------------------------------------
            % Get all the Variable Data (Loans, Facility,and Borrower),
            % associated with the specific filedate
            
            % Start with the loan data, set the 'L' table to hold all loan 
            % data from the specific file date.
            idx_fd_L = DB.LoanDataTable.GimmeCLAmatrix("file_date") == FileDate;
            L = DB.LoanDataTable.DataMat(idx_fd_L,:);
            VariableNames = DB.LoanDataTable.VariableNames;
            VariableNames_L = cellstr(strcat("L_",VariableNames));
            if size(L,1)<1
                errormsg = sprintf('cannot find Loan data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.L = L;
            assignin("base","L",array2table(L,"VariableNames",VariableNames_L))
            

            % Set the F table to hold all of the Facilities data from the
            % specific file date.
            idx_fd_F = DB.FacilitiesDataTable.GimmeCLAmatrix("file_date") == FileDate;
            F = DB.FacilitiesDataTable.DataMat(idx_fd_F,:);
            VariableNames = DB.FacilitiesDataTable.VariableNames;
            VariableNames_F = cellstr(strcat("F_",VariableNames));
            if size(F,1)<1
                errormsg = sprintf('cannot find Facility data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.F = F;
            assignin("base","F",array2table(F,"VariableNames",VariableNames_F))

            % Variable Borrower Data
            idx_fd_BV = DB.BorrowerVariableDataTable.GimmeCLAmatrix("file_date") == FileDate;
            BV = DB.BorrowerVariableDataTable.DataMat(idx_fd_BV,:);
            VariableNames = DB.BorrowerVariableDataTable.VariableNames;
            VariableNames_B = cellstr(strcat("B_",VariableNames));
            if size(BV,1)<1
                errormsg = sprintf('cannot find Borrower (variable) data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.BV = BV;



            % Link Facility Data based on Facility ID
            idx_facid_L = strcmpi(DB.LoanDataTable.VariableNames,"Facility_ID");
            if sum(idx_facid_L)~=1
                errmsg = sprintf('cannot find Facility ID in Loan Data Table.\n');
                error(errmsg);
            end
            idx_facid_F = strcmpi(DB.FacilitiesDataTable.VariableNames,"Facility_ID");
            if sum(idx_facid_F)~=1
                errmsg = sprintf('cannot find Facility ID in Facility Data Table.\n');
                error(errmsg);
            end            
            [ina_facID, locb_facID] = ismember(L(:,idx_facid_L),F(:,idx_facid_F));
            LF = [L(ina_facID,:),F(locb_facID(ina_facID),:)];
            VariableNames_LF = [VariableNames_L,VariableNames_F];

            % Link Borrower Variable Data using Borrower ID
            idx_borID_LF = strcmpi(VariableNames_LF,"L_borrower_ID");
            idx_borID_BV = strcmpi(DB.BorrowerVariableDataTable.VariableNames,"borrower_ID");
            [ina_borID, locb_borID] = ismember(LF(:,idx_borID_LF),BV(:,idx_borID_BV));
            LFBV = [LF(ina_borID,:),BV(locb_borID(ina_borID),:)];
            VariableNames_LFBV = [VariableNames_LF,VariableNames_B];
            Diagnostics.idx_bordID_LF = idx_borID_LF;
            Diagnostics.idx_bordID_BV = idx_borID_BV;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;



            % STATIC DATA -------------------------------------------------
            % Note that, by definition, Static data doesn't vary by date,
            % so we don't need to select the data specific to the input
            % file date.  Otherwise, we keep the algorithm consistent with
            % the other CLAdataTables.
            BS = DB.BorrowerStaticDataTable.DataMat;
            VariableNames = DB.BorrowerStaticDataTable.VariableNames;
            VariableNames_S = cellstr(strcat("S_",VariableNames));

            % Link static data using Borrower ID
            bid_BS = BS(:,strcmpi(VariableNames_S,"S_borrower_ID"));
            bid_LFBV = LFBV(:,strcmpi(VariableNames_LFBV,"L_borrower_ID"));
            [ina_borID, locb_borID] = ismember(bid_LFBV,bid_BS);
            LFBVS = [LFBV(ina_borID,:),BS(locb_borID(ina_borID),:)];
            VariableNamesFinal = [VariableNames_LFBV,VariableNames_S];



            % OUTPUT ------------------------------------------------------
            Diagnostics.L = L;
            Diagnostics.LVN = VariableNames_L;
            Diagnostics.F = F;
            Diagnostics.FVN = VariableNames_F;
            Diagnostics.BV = BV;
            Diagnostics.BVVN = VariableNames_B;
            Diagnostics.LF = LF;
            Diagnostics.LFVN = VariableNames_LF;
            Diagnostics.BS = BS;
            Diagnostics.BSVN = VariableNames_S;
            Diagnostics.LFBV = LFBV;
            Diagnostics.LFBVVN = VariableNames_LFBV;
            Diagnostics.H = LFBVS;

            Diagnostics.VariableNamesFinal = VariableNamesFinal;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;
            
            MAT = LFBVS;
            VariableNames = VariableNamesFinal;

        end

        function [MAT,VariableNames] = GimmeCLAHistMat(DB,varargin)
            %
            % GimmeCLAHistMat
            %   Returns the full historical
            %
            %
            % -------------------------------------------------------------

            % GET INPUTS --------------------------------------------------
            % Get full list of filedates (we need to get this before
            % dealing with optional inputs because it is the default list
            % of file dates for the FileDates optional input variable).
            FileDateTab = DB.fileDatesTab;

            % Parse optional inputs
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;            
            
            % FileDates
            % Add optional input for File Dates (list of dates included in
            % the historical matrix returned)
            def = FileDateTab.FileDate;
            addParameter(p,'FileDates',def,@(x) isnumeric(x));

            % Add optional input for File Date Index (logical index
            % selecting which file dates (based on the file date table) to
            % include in the historical matrix returned)
            def = true(size(FileDateTab.FileDate));
            addParameter(p,'FileDateIndex',def,@(x) islogical(x));            

            % Parse and set results
            parse(p,varargin{:});

            % The user cannot input both an index and a list of dates, if
            % he does, we go with the list of dates.
            if any(strcmpi(varargin,"filedates"))
                FileDateIndex = true(size(p.Results.FileDates));
            else
                FileDateIndex = p.Results.FileDateIndex;
            end

            % For filedates we use the provided value.  If the user 
            % provided a filedates input, the index is set to all true, so 
            % all provided filedates are used.  If the user provided a
            % filedateindex value and no filedates value, we limit the
            % filedates used to those indicated by the index.
            filedates = p.Results.FileDates(FileDateIndex);


            % BUILD MATRIX ------------------------------------------------
            % Initialize
            H = [];

            % Loop through each file date and build the full historical
            % matrix
            for d = 1:length(filedates)

                fd = filedates(d);
                [M,VN,~] = GimmeCLAMat(DB,fd);
                H = [H;M];

            end

            % ORGANIZE OUTPUTS --------------------------------------------
            MAT = H;
            VariableNames = VN;
        
        end

        function TAB = GimmeCLATable(DB,FileDate)
            % 
            % GimmeCLATable
            %   Returns full data table, for a specific File Date 
            %   matching by FileDate, and joined by facility and 
            %   borrower.
            %
            % -------------------------------------------------------------
            

            error("GimmeCLATable method no longer available")
            % Get the Matrix for the Specific File Date
            %[MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate);

            % Convert the Matrix to a Table
            %LFVS = array2table(MAT,'VariableNames',VariableNames);

            % SINGLE PRICING DECISION
            % -------------------------------------------------------------
            %LFVS.SPD_ID = SinglePriceDecision(LFVS, {'BankID','file_date','CustomerKey','SpreadBPS'});
            %TAB = LFVS;
            %TAB = movevars(TAB, "SPD_ID", "Before", "BankID");
            

 


        end

        function [TAB,SPIDdups] = GimmeCLAHistTab(DB,varargin)
            % 
            % GimmeCLAHistTab
            %
            % -------------------------------------------------------------

            % GET INPUTS --------------------------------------------------
            % Get full list of filedates (we need to get this before
            % dealing with optional inputs because it is the default list
            % of file dates for the FileDates optional input variable).
            FileDateTab = DB.fileDatesTab;

            % Parse optional inputs
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;            
            
            % FileDates
            % Add optional input for File Dates (list of dates included in
            % the historical matrix returned)
            def = FileDateTab.FileDate;
            addParameter(p,'FileDates',def,@(x) isnumeric(x));

            % Add optional input for File Date Index (logical index
            % selecting which file dates (based on the file date table) to
            % include in the historical matrix returned)
            def = true(size(FileDateTab.FileDate));
            addParameter(p,'FileDateIndex',def,@(x) islogical(x));            

            % Parse and set results
            parse(p,varargin{:});

            % The user cannot input both an index and a list of dates, if
            % he does, we go with the list of dates.
            idx_have_filedates = any(cell2mat(...
                cellfun(@(x) strcmpi("filedates",x),...
                varargin,'UniformOutput',false)));
            if idx_have_filedates
                FileDateIndex = true(size(p.Results.FileDates));
            else
                FileDateIndex = p.Results.FileDateIndex;
            end

            % For filedates we use the provided value.  If the user 
            % provided a filedates input, the index is set to all true, so 
            % all provided filedates are used.  If the user provided a
            % filedateindex value and no filedates value, we limit the
            % filedates used to those indicated by the index.
            filedates = p.Results.FileDates(FileDateIndex);

            % GET MATRIX --------------------------------------------------
            [M,VariableNames] = GimmeCLAHistMat(DB,'FileDates',filedates);

            % CONVERT TO TABLE --------------------------------------------
            T = array2table(M,'VariableNames',VariableNames);

            % SINGLE PRICING DECISION -------------------------------------
            matchvars ={'L_Bank_ID','L_file_date','L_borrower_ID','L_spread_bps'};
            [T.PriceDecisionID,dups] =  DB.SinglePriceDecision(T,matchvars);
            T = movevars(T, "PriceDecisionID", "Before", 1);

            % ORGANIZE OUTPUT ---------------------------------------------
            SPIDdups = dups;
            TAB = T;

        end

        function [PriceDecisionID,dups] =  SinglePriceDecision(DB,TAB,matchvars)
            % 
            % SINGLE PRICING DECISION
            % If there are multiple loans made within the same period
            % between the same bank and the same borrower, we consider
            % that a "single pricing decision", those prices are grouped
            % together as one.
            % -------------------------------------------------------------
            
            % t is a smaller version of TAB, with just the matched
            % variables.  Observations (rows) that match for these
            % variables should be treated as a single observation.
            %matchvars ={'BankID','ProcessingDateKey','CustomerKey','SpreadBPS'}; 
            t = TAB(:,matchvars);
            
            % Find duplicate rows in t
            % use grpstats to group the table by the matchvars, rows with
            % more than one GroupCount will have duplicate observations.
            g = grpstats(t,matchvars);
            idx_dups = g.GroupCount>1;
            
            % Create an id column (PriceDecisionID) unique for each pricing
            % decision
            [~,PriceDecisionID] = ismember(t(:,matchvars),g(:,matchvars),'rows');
            
            % Once we have identified the observations that match (the
            % single pricing decision observations), we pull those out and
            % store them in the singlepricedec table (can be returned for
            % reference).
            [idx_singlepricedec,locb] = ismember(TAB(:,matchvars),g(idx_dups,matchvars));
            dups = TAB(idx_singlepricedec,:);
            dups.ID = locb(idx_singlepricedec);
            dups = movevars(dups, "ID", "Before", 1);


        end

        function FileDateTab = fileDatesTab(DB)
            %
            % FileDateTab
            %
            % Returns a table with all of the available file dates in a 
            % CLAdataBase as well as the date parts (year, month, day, and
            % full date).
            % -------------------------------------------------------------

            
            FileDateTab = array2table(DB.AvailableFileDates, 'VariableNames',{'FileDate'});
            FileDateTab.FileDateYears = year(FileDateTab.FileDate);
            FileDateTab.FileDateMonths = month(FileDateTab.FileDate);
            FileDateTab.FileDateDays = day(FileDateTab.FileDate);
            FileDateTab.FileDates = datetime(FileDateTab.FileDateYears,FileDateTab.FileDateMonths,FileDateTab.FileDateDays);



        end

        function [POPGRID, OBS_FULL, diagnostics] = GimmeOBS(DB,GRID,filedate)
            %
            % returns the OBStab (observation table) for the given file
            % date. the OBStab translates the observations into the defined
            % groups as per the grid.
            %
            %
            %
            %
            %
            % -------------------------------------------------------------

            % Get the full historical data set in the DB ------------------
            H = DB.H;
            
            % Initialize --------------------------------------------------
            % Initialize the Dimensions Cell Array and the Diagnostics structure
            dimensions = struct;
            diagnostics = struct();

            % Create the Spread Variable ----------------------------------
            h0 = H;
            h0.SPR = h0.L_spread_bps;
            h0 = movevars(h0, "SPR", "Before", 1);


            % Create the Lag Variable (Lag) -------------------------------
            % We create the lag by calcuating the difference between the selected
            % filedate and the file date in the historical observation data.  Positive
            % numbers represent historical dates and negative numbers would represent
            % future dates (so they match the lags in the GRID).
            h0.Lag = calmonths(between(datetime(h0.L_file_date,'convertfrom','datenum'),filedate,'months'));
            h0 = movevars(h0, "Lag", "Before", 2);
            assignin("base",'h0',h0)
            
            % Keep only data within the maximum lag period
            idx_lagKeep = ismember(h0.Lag,GRID.Lag.Lag);
            diagnostics.idx_lagKeep = idx_lagKeep;
            
            % Add variable to dimensions cell
            dimensions.Lag.gridvar = 'Lag';
            dimensions.Lag.distvar = 'Lag';
            
            % New Or Renewal (REMOVE UNWANTED RECORDS) --------------------
            % the GRID may include, new originations, renewals, or both.  Here we
            % remove any origination type that the user does not want to included in
            % the grid.
            idx_includeOrigination = ismember(h0.L_Loan_Origination_Status,GRID.NewOrRenewal);
            diagnostics.idx_includeOrigination = idx_includeOrigination;
            h0.NewOrRenewal = h0.L_Loan_Origination_Status;
            h0 = movevars(h0, "NewOrRenewal", "Before", 3);
            
            % NOTE: New or Renewal is not a dimension along which we measure distance,
            % it is a way we may or may not limit the data.

            % Index/Rate Type (REMOVE UNWANTED RECORDS) -------------------
            % the GRID will be limited to loans of a given index (i.e. LIBOR/SOFR,
            % PRIME, Fixed).  Since the Rate/Index is affected by two  different
            % variables in the data (Index and RateType), the grid stores a table with
            % both variables.
            indexIDs = GRID.RateType.IndexIDs{GRID.RateType.USE};
            pricingStructureIDs = GRID.RateType.PricingStructureIDs(GRID.RateType.USE);
            idx_index2Include = and(ismember(h0.L_Index,indexIDs),ismember(h0.L_pricing_structure,pricingStructureIDs));
            diagnostics.idx_index2Include = idx_index2Include;
            h0.RateType = h0.L_Index;
            h0 = movevars(h0, "RateType", "Before", 1);
            
            % NOTE: Index/Rate Type is not a dimension along which we measure distance,
            % it is a way we may or may not limit the data.

            % Facility Type -----------------------------------------------
            % the GRID may be limited to certain facility types as selected by the user
            h0.FacilityType = h0.L_Loan_Type;
            h0 = movevars(h0, "FacilityType", "Before", 1);

            % Add variable to dimensions cell
            dimensions.FacilityType.gridvar = 'FacilityType';
            dimensions.FacilityType.distvar = 'FacilityType';

            % Create the Loan Size Group ----------------------------------
            % This code block divides the portfolio into groups based on
            % CommitmentAmt at each break point.  If there are n break points,
            % there will be n+1 groups.
            % Loans with sizes outside of the range will not be removed,
            % but the loan size groups will be limited to those within the
            % range (only those groups will be shown in the grid).
            LoanSizeBreakPoints = 1000000 .* GRID.LoanSize.Groups;
            h0.LoanSizeGroup = ones(size(h0,1),1);
            for p = 1:length(LoanSizeBreakPoints)
                bp = LoanSizeBreakPoints(p);
                idx_greaterThanBreak = h0.F_Commitment_Amount > bp;
                h0.LoanSizeGroup(idx_greaterThanBreak) = p+1;
            end
            
            
            % Move the variables
            h0.LoanSize = h0.F_Commitment_Amount;
            h0 = movevars(h0, "LoanSizeGroup", "Before", 3);
            h0 = movevars(h0, "LoanSize", "Before", 3);            
            
            % check
            diagnostics.chk_LoanSizeGroup = grpstats(h0(:,{'LoanSize','F_Commitment_Amount'}),"LoanSize",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.LoanSize.gridvar = 'LoanSizeGroup';
            dimensions.LoanSize.distvar = 'LoanSize';            
            
            % Identify NaN Loan Sizes
            idx_BadLoanSize = isnan(h0.LoanSize);
            diagnostics.idx_BadLoanSize = idx_BadLoanSize;


            % Create the Risk Category Group ------------------------------
            % This code block divides the portfolio into groups based on
            % Risk Rating (PD) at each break point.  If there are n break points,
            % there will be n+1 groups
            RiskCatBreakPoints = GRID.RiskCategories.Groups;
            h0.RiskCategories = ones(size(h0,1),1);
            for p = 1:length(RiskCatBreakPoints)
                bp = RiskCatBreakPoints(p);
                idx_greaterThanBreak = h0.B_Risk_Rating > bp;
                h0.RiskCategories(idx_greaterThanBreak) = p+1;
            end
            
            % identify records with risk rating outside of the set range
            idx_outOfRiskBounds = or(h0.B_Risk_Rating<GRID.RiskCategories.Min,...
                h0.B_Risk_Rating>GRID.RiskCategories.Max);
            diagnostics.idx_outOfRiskBounds = idx_outOfRiskBounds;
            
            % Move the variable
            h0 = movevars(h0, "RiskCategories", "Before", 3);
            
            % check
            diagnostics.chk_RiskRatings = grpstats(h0(:,{'RiskCategories','B_Risk_Rating'}),"RiskCategories",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.RiskCategories.gridvar = 'RiskCategories';
            dimensions.RiskCategories.distvar = 'RiskCategories';                
            
            % Identify NaN RiskRatings
            diagnostics.idx_BadRiskRating = isnan(h0.RiskCategories);

            % Create Term Category Groups ---------------------------------
            % This code block divides the portfolio into groups based on
            % Term at each break point.  If there are n break points,
            % there will be n+1 groups
            
            % Start by calculating term from start date and maturity date of the loan
            %h0.TermMonths = calmonths(between(...
            %    datetime(h0.L_loan_effective_date,'convertfrom','datenum'),...
            %    datetime(h0.L_loan_maturity_date,'convertfrom','datenum'),...
            %    'months'));
            h0.Term = log(h0.TermMonths);
            
            TermCatBreakPoints = GRID.TermCategories.Groups;
            h0.TermCategories = ones(size(h0,1),1);
            for p = 1:length(TermCatBreakPoints)
                bp = TermCatBreakPoints(p);
                idx_greaterThanBreak = h0.TermMonths > bp;
                h0.TermCategories(idx_greaterThanBreak) = p+1;
            end
            
            % Remove records with risk rating outside of the set range
            diagnostics.idx_outOfRiskBounds = or(h0.TermMonths<GRID.TermCategories.Min,...
                h0.TermMonths>GRID.TermCategories.Max);
            
            % Move the variable
            h0 = movevars(h0, "TermCategories", "Before", 4);
            h0 = movevars(h0,"TermMonths","Before",4);
            
            % check
            diagnostics.chk_TermGroup = grpstats(h0(:,{'TermCategories','TermMonths'}),"TermCategories",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.TermCategories.gridvar = 'TermCategories';
            dimensions.TermCategories.distvar = 'Term';                
            
            % Identify NaN Terms Sizes
            diagnostics.idx_BadTermCategories = isnan(h0.TermCategories);



            % Collateral Group --------------------------------------------
            % Assign a collateral group to each loan in the observations
            
            % Initialize
            h0.CollateralGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, "CollateralGroups", "Before", 5);
            
            % Loop through each Collateral category and assign its Id to the
            % appropriate loan observations
            gridids = GRID.CollateralGroups.SecGID;
            for c = 1:length(gridids)

                try
                
                    gridid = gridids(c);

                    % Sometimes it seems that the collateral IDs are in a
                    % cell, if they are, we pull them out.
                    CollateralIds = GRID.CollateralGroups.SecurityCategoryIDs{c};
                    if iscell(CollateralIds)
                        fprintf('unwrapping collateral ids...')
                        CollateralIds = CollateralIds{:,:};
                        fprintf('out of cell.\n')
                    end

                    % If there is only one Collateral ID (scalar), we use
                    % == otherwise we use ismember
                    if isscalar(CollateralIds)
                        idx_inCurrentCollateralGroup = h0.L_Collateral_Type == CollateralIds;
                    else
                        idx_inCurrentCollateralGroup = ismember(h0.L_Collateral_Type,CollateralIds);
                    end
                    h0.CollateralGroups(idx_inCurrentCollateralGroup) = gridid;

                catch ME
                    assignin("base",'CollateralIds',CollateralIds)
                    assignin("base","h0",h0)
                    assignin("base","c",c)
                    rethrow(ME)
                end

            
            end
            
            % Add variable to dimensions cell
            dimensions.CollateralGroups.gridvar = 'CollateralGroups';
            dimensions.CollateralGroups.distvar = 'CollateralGroups';   

            % Identify NaN Collateral Groups
            diagnostics.idx_BadCollateralGroup = isnan(h0.CollateralGroups);



            % Industry Group ----------------------------------------------
            % Assign an industry group to each loan in the observations
            
            % Create 2-digit NAICS code
            h0.NAICS2 = floor(h0.B_NAICS_code ./ 10000);
            h0 = movevars(h0, "NAICS2", "Before", "B_NAICS_code");
            
            % Initialize
            h0.IndustryGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, "IndustryGroups", "Before", 6);
            
            % Loop through each Industry category and assign its Id to the
            % appropriate loan observations
            indids = GRID.IndustryGroups.IndGrpID;
            for c = 1:length(indids)
            
                indid = indids(c);
                IndustryIds = GRID.IndustryGroups.NAICS2s{c};
                idx_inCurrentIndustryGroup = ismember(h0.NAICS2,IndustryIds);
                h0.IndustryGroups(idx_inCurrentIndustryGroup) = indid;
            
            end
            
            % Add variable to dimensions cell
            dimensions.IndustryGroups.gridvar = 'IndustryGroups';
            dimensions.IndustryGroups.distvar = 'IndustryGroups';   
            
            % Identify NaN Industry Groups
            diagnostics.idx_BadIndustryGroup = isnan(h0.IndustryGroups);



            % Geographies -------------------------------------------------
            % Assign a Geography ID to each loan. The Geography field is a
            % multi vector field.

            % First we get the location variables table (matches the
            % location name variables with the id variables), the
            % defGeographyTable function can return this table.
            [~,~,~,LocVarsTab] = defGeographyTable(DB.TaxonomyTabs.LocationDatabase);

            % Identify which variables (ID variables) are used in the GRID
            % to define geography
            idx_locIDVars = ismember(GRID.Geographies.Properties.VariableNames, LocVarsTab.LocIDVar);
            GRIDlocIDVars = GRID.Geographies.Properties.VariableNames(idx_locIDVars);

            % the observation data only has zip codes, so we need to match
            % each location by zipcode
            [ina_zips, locb_zips] = ismember(h0.B_Zipcode,DB.TaxonomyTabs.LocationDatabase.zip_numeric);
            geographies = NaN(size(h0,1),length(GRIDlocIDVars));
            geographies(ina_zips,:) = DB.TaxonomyTabs.LocationDatabase{locb_zips(ina_zips),GRIDlocIDVars};
            
            % Add geography variable to historical data table
            h0.Geographies = geographies;
            h0 = movevars(h0, "Geographies", "Before", 7);

            % Add variable to dimensions cell
            dimensions.Geographies.gridvar = 'Geographies';
            dimensions.Geographies.distvar = 'Geographies';
                        
            % Identify NaN Geographies (cant find zips)
            diagnostics.idx_BadGeographyGroup = isnan(any(h0.Geographies));

            % Remove Excluded Loans ---------------------------------------
            idx_KEEP = all([diagnostics.idx_lagKeep,...
                diagnostics.idx_includeOrigination,...
                diagnostics.idx_index2Include],2);
            h1 = h0(idx_KEEP,:);



            % Combine by Pricing Decision ---------------------------------
            idx_PriceDecisionZero = h1.PriceDecisionID == 0;
            h2 = h1(~idx_PriceDecisionZero,:);
            diagnostics.PriceDecisionZero = h0(idx_PriceDecisionZero,:);
            
            
            OBSvarNames = {'FacilityType','Lag','RiskCategories','TermMonths','TermCategories','CollateralGroups',...
                'IndustryGroups','Geographies','LoanSize','LoanSizeGroup','NewOrRenewal','RateType','SPR'};
            OBS_FULL = h2(:,[{'PriceDecisionID'},OBSvarNames]);

            
            % Group by pricing decision, taking median of grouped variables. Then
            % remove the median_ prefix to the variable names.
            G_med = grpstats(OBS_FULL,"PriceDecisionID","median");
            G_med.Properties.VariableNames = strrep(G_med.Properties.VariableNames, "median_","");
            
            % Group by pricing decision, taking mode of grouped variables. Then remove 
            % the mode_ prefix to the variable names.
            G_mod = grpstats(OBS_FULL,"PriceDecisionID","mode");
            G_mod.Properties.VariableNames = strrep(G_mod.Properties.VariableNames, "mode_","");
            
            % Construct the Observations Table using mode for categorical variables and
            % median for numeric variables
            OBS = [G_med(:,{'PriceDecisionID','GroupCount','SPR'}),...
                G_mod(:,cellstr(char(GRID.Categoricals.Property(GRID.Categoricals.IsCat)))),...
                G_med(:,cellstr(char(GRID.Categoricals.Property(~GRID.Categoricals.IsCat))))];
            OBS.OBS_ID = [1:size(OBS,1)];
            OBS = movevars(OBS, "OBS_ID", "Before", 1);

            % Remove any observations with NaN values
            %diagnostics.idx_OBSNaN = any(isnan(OBS{:,:}),2);
            diagnostics.idx_OBSNaN = isnan(OBS.SPR);
            OBS = OBS(~diagnostics.idx_OBSNaN,:);

            % Store information in a CLApopulatedGrid ---------------------
            POPGRID = CLApopulatedGrid(GRID);
            POPGRID.OBS = OBS;
            POPGRID.dimensions = defDimensionsStruct(POPGRID.POPULATED_GRID);


        end
    end
end