<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>CLAgrid</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-12-18">
<meta name="DC.source" content="CLAgrid.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">
<span class="keyword">classdef</span> CLAgrid
    <span class="comment">%</span>
    <span class="comment">% CLAgrid</span>
    <span class="comment">%</span>
    <span class="comment">% CLAgrid is a class object holding the grid information for the CLA</span>
    <span class="comment">% Pricing Interpolation Tool</span>
    <span class="comment">%</span>
    <span class="comment">%</span>

    <span class="keyword">properties</span>
        Description         <span class="comment">% Description of the grid</span>

        CreatedOn           <span class="comment">% Date on which the grid was created</span>

        LoanSize            <span class="comment">% A Structure holding information related to loan</span>
                            <span class="comment">% size range and the group splits.</span>

        RiskCategories      <span class="comment">% A Structure holding information related to risk</span>
                            <span class="comment">% category range and the group splits.</span>

        TermCategories      <span class="comment">% A Structure holding information related to term</span>
                            <span class="comment">% range and the group splits.</span>

        Geographies         <span class="comment">%</span>
        CollateralGroups    <span class="comment">%</span>
        IndustryGroups      <span class="comment">%</span>
        RateType            <span class="comment">%</span>
        FacilityType        <span class="comment">%</span>
        NewOrRenewal        <span class="comment">%</span>

        Weights             <span class="comment">%</span>
        Lag                 <span class="comment">%</span>

        Categoricals        <span class="comment">% Categoricals is a table that indicates which</span>
                            <span class="comment">% of the dimensions are categorical (as opposed</span>
                            <span class="comment">% to those that are ordinalt or continuous).</span>

        REQTABLE            <span class="comment">% REQ_TABLE is the table holding all of the</span>
                            <span class="comment">% grid squares but is UNPOPULATED</span>


    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> obj = CLAgrid(TAXONOMYTABS,varargin)
            <span class="comment">% -------------------------------------------------------------</span>
            <span class="comment">%</span>
            <span class="comment">% CLAgrid</span>
            <span class="comment">%  Construct an instance of the CLAgrid class object</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% DESCRIPTION</span>
            def = sprintf(<span class="string">"CLA Grid created on %s"</span>,datetime());
            defmsg = sprintf([<span class="string">'Problem with the grid description input. the '</span> <span class="keyword">...</span>
                <span class="string">'description must be a string'</span>]);
            addParameter(p,<span class="string">'Description'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(isstring(x),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );


            <span class="comment">% CREATEDON</span>
            def = datetime();

            defmsg = sprintf([<span class="string">'Problem with the grid created on input. the '</span> <span class="keyword">...</span>
                <span class="string">'created-on-date (CreatedOn) must be a date'</span>]);
            addParameter(p,<span class="string">'CreatedOn'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(isdatetime(x),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% LOAN SIZE (LoanSize)</span>
            <span class="comment">% Add optional input for LoanSize data structure</span>
            def = struct();
            def.Min = 0;
            def.Max = 100;
            def.Groups = [0.25,0.5,1,5,10,50];
            defmsg = sprintf([<span class="string">'Problem with the LoanSize input. LoanSize must'</span> <span class="keyword">...</span>
                <span class="string">' be a structure with the fields "Min", "Max", and "Groups".'</span> <span class="keyword">...</span>
                <span class="string">'  "Groups" must be a row vector, and "Max" must be greater'</span> <span class="keyword">...</span>
                <span class="string">' than "Miin"'</span>]);
            addParameter(p,<span class="string">'LoanSize'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(x.Max &gt; x.Min,<span class="keyword">...</span>
                and(size(x.Groups,1)==1,<span class="keyword">...</span>
                all(strcmpi(sort(fieldnames(x)),{<span class="string">'Groups'</span>;<span class="string">'Max'</span>;<span class="string">'Min'</span>})))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% RISK CATEGORIES (RiskCategories)</span>
            <span class="comment">% Add optional input for LoanSize data structure</span>
            def = struct();
            def.Min = 1;
            def.Max = 12;
            def.Groups = [3,7];
            defmsg = sprintf([<span class="string">'Problem with the Risk Categories input. RiskCategories must'</span> <span class="keyword">...</span>
                <span class="string">' be a structure with the fields "Min", "Max", and "Groups".'</span> <span class="keyword">...</span>
                <span class="string">'  "Groups" must be a row vector, and "Max" must be greater'</span> <span class="keyword">...</span>
                <span class="string">' than "Min"'</span>]);
            addParameter(p,<span class="string">'RiskCategories'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(x.Max &gt; x.Min,<span class="keyword">...</span>
                and(size(x.Groups,1)==1,<span class="keyword">...</span>
                all(strcmpi(sort(fieldnames(x)),{<span class="string">'Groups'</span>;<span class="string">'Max'</span>;<span class="string">'Min'</span>})))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% TERM CATEGORIES (TermCategories)</span>
            <span class="comment">% Add optional input for term data structure</span>
            def = struct();
            def.Min = 1;
            def.Max = 120;
            def.Groups = [36,72];
            defmsg = sprintf([<span class="string">'Problem with the Term Categories input. TermCategories must'</span> <span class="keyword">...</span>
                <span class="string">' be a structure with the fields "Min", "Max", and "Groups".'</span> <span class="keyword">...</span>
                <span class="string">'  "Groups" must be a row vector, and "Max" must be greater'</span> <span class="keyword">...</span>
                <span class="string">' than "Miin"'</span>]);
            addParameter(p,<span class="string">'TermCategories'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(x.Max &gt; x.Min,<span class="keyword">...</span>
                and(size(x.Groups,1)==1,<span class="keyword">...</span>
                all(strcmpi(sort(fieldnames(x)),{<span class="string">'Groups'</span>;<span class="string">'Max'</span>;<span class="string">'Min'</span>})))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% COLLATERAL TYPES (CollateralGroups)</span>
            <span class="comment">% Add optional input for Collateral type data</span>
            allCollateralTypeIDs = TAXONOMYTABS.Collateral_Type.Collateral_Type;
            allCollateralTypes = categorical(TAXONOMYTABS.Collateral_Type.Collateral_Type_Name);
            weakCollateralTypes = categorical([<span class="keyword">...</span>
                <span class="string">"All Assets"</span>;
                <span class="string">"Cash and Cash Equivalent"</span>;
                <span class="string">"Commercial Vehicles"</span>;
                <span class="string">"Consumer Vehicles"</span>;
                <span class="string">"Land"</span>;
                <span class="string">"Real Estate (residential)"</span>; <span class="keyword">...</span>
                <span class="string">"Unsecured"</span>]);
            weakCollateralTypeIDs = allCollateralTypeIDs(ismember(weakCollateralTypes,allCollateralTypes));
            strongCollateralTypes = setdiff(allCollateralTypes,weakCollateralTypes);
            strongCollateralTypeIDs = setdiff(allCollateralTypeIDs,weakCollateralTypeIDs);
            def = array2table([{<span class="keyword">...</span>
                <span class="string">'weak'</span>,   {weakCollateralTypeIDs}, {weakCollateralTypes};<span class="keyword">...</span>
                <span class="string">'strong'</span>, {strongCollateralTypeIDs}, {strongCollateralTypes}<span class="keyword">...</span>
                }],<span class="string">'VariableNames'</span>,{<span class="string">'SecurityGroup'</span>,<span class="string">'SecurityCategoryIDs'</span>,<span class="string">'SecurityTypes'</span>});
            def.SecGID = [1:size(def,1)]';
            def = movevars(def, <span class="string">"SecGID"</span>, <span class="string">"Before"</span>, <span class="string">"SecurityGroup"</span>);
            defmsg = sprintf([<span class="string">'Problem with the Security Key Table. SecurityKeyTable must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with the Variables "SecurityGroup", "SecurityCategoryIDs", and "SecurityTypes".'</span> <span class="keyword">...</span>
                <span class="string">'  "Groups" must be a row vector, and "Max" must be greater'</span> <span class="keyword">...</span>
                <span class="string">' than "Miin"'</span>]);
            addParameter(p,<span class="string">'CollateralGroups'</span>,def, @(x) assert(istable(x), defmsg));


            <span class="comment">% INDUSTRIES</span>
            def = defIndustryTab();
            defmsg = sprintf([<span class="string">'Problem with the Industry Table. IndustryTable must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with the Variables "IndGrpID","IndGrpName","NAICS2s","NAICSIndustries".'</span> <span class="keyword">...</span>
                ]);
            addParameter(p,<span class="string">'IndustryGroups'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(istable(x),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% GEOGRAPHIES</span>
            <span class="comment">% Geographies are stored in a table</span>
            [~ ,def,~] = defGeographyTable(TAXONOMYTABS.LocationDatabase);

            <span class="comment">% Set the level order (rank) for each of the geographies. The</span>
            <span class="comment">% geographies are listed from larger to smaller. Metro/Rural is</span>
            <span class="comment">% considered at the level just above MSA.</span>
            defmsg = sprintf([<span class="string">'Problem with the Geography Table. Geography table must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with the Variables "Include","LevelIdVar", "LevelNameVar", and "Rank".'</span> <span class="keyword">...</span>
                ]);
            addParameter(p,<span class="string">'Geographies'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(istable(x),<span class="keyword">...</span>
                istable(x)),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% RATE TYPE/INDEX</span>
            <span class="comment">% Rate type is a scalar providing the rate/indices for which</span>
            <span class="comment">% the grid applies</span>
            def = defRatesTab();
            defmsg = sprintf([<span class="string">'Problem with the Rates Table. Rates table must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with the Variables "Index","USE","IndexIDs","PricingStructureIDs".'</span> <span class="keyword">...</span>
                ]);

            addParameter(p,<span class="string">'RateType'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(istable(x),<span class="keyword">...</span>
                and(all(strcmpi(sort(x.Properties.VariableNames),{<span class="string">'Index'</span>,<span class="string">'IndexIDs'</span>,<span class="string">'PricingStructureIDs'</span>,<span class="string">'USE'</span>})),<span class="keyword">...</span>
                all(strcmpi(sort(x.Properties.VariableNames),{<span class="string">'Index'</span>,<span class="string">'IndexIDs'</span>,<span class="string">'PricingStructureIDs'</span>,<span class="string">'USE'</span>})))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% FACILITY TYPES</span>
            <span class="comment">% facility types is a vector providing the facility types (IDX)</span>
            <span class="comment">% for which the grid applies</span>
            def = [1,2];

            sprintf([<span class="string">'Problem with the Facility type '</span> <span class="keyword">...</span>
                <span class="string">'(revolving/non-revolving) selection. The origination type must'</span> <span class="keyword">...</span>
                <span class="string">' be a vector value with a maximum value of 2.'</span> <span class="keyword">...</span>
                ]);
            addParameter(p,<span class="string">'FacilityType'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(isvector(x),max(x)&lt;3),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );


            <span class="comment">% ORIGINATION TYPES</span>
            <span class="comment">% NewOrRenewal is a vector providing the origination types for</span>
            <span class="comment">% which the grid applies</span>
            def = [1;2];

            defmsg = sprintf([<span class="string">'Problem with the origination type '</span> <span class="keyword">...</span>
                <span class="string">'(new/renewal) selection. The origination type must'</span> <span class="keyword">...</span>
                <span class="string">' be a vector value with a maximum value of 2.'</span> <span class="keyword">...</span>
                ]);
            addParameter(p,<span class="string">'NewOrRenewal'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(isvector(x),max(x)&lt;3),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );



            <span class="comment">% WEIGHTS</span>
            <span class="comment">% Weights (on each of the different dimensions in the grid) are</span>
            <span class="comment">% stored in a weights table</span>
            def = table();
            def.CollateralGroups(<span class="string">'Raw'</span>)                 = 15;
            def.Geographies(<span class="string">'Raw'</span>)                      = 15;
            def.LoanSize(<span class="string">'Raw'</span>)                         = 5;
            def.TermCategories(<span class="string">'Raw'</span>)                   = 10;
            def.RiskCategories(<span class="string">'Raw'</span>)                   = 20;
            def.Lag(<span class="string">'Raw'</span>)                              = 25;
            def.FacilityType(<span class="string">'Raw'</span>)                     = 5;
            def.IndustryGroups(<span class="string">'Raw'</span>)                   = 5;
            def(<span class="string">'Scaled'</span>,:) = def(<span class="string">'Raw'</span>,:) ./ sum(def{<span class="string">'Raw'</span>,:});

            defmsg = sprintf([<span class="string">'Problem with the Weights Table. Weights table must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with the Variables "FacilityType","IndustryGroups","Lag","LoanSize", "Location",'</span> <span class="keyword">...</span>
                <span class="string">'"RiskCategories", "CollateralGroups", "TermCategories".'</span> <span class="keyword">...</span>
                ]);
            addParameter(p,<span class="string">'Weights'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(istable(x),<span class="keyword">...</span>
                and(all(strcmpi(sort(x.Properties.VariableNames),{<span class="string">'FacilityType'</span>,<span class="string">'Industry'</span>,<span class="string">'Lag'</span>,<span class="string">'LoanSize'</span>, <span class="string">'Location'</span>,<span class="string">'SPRiskGroup'</span>, <span class="string">'Security'</span>, <span class="string">'Term'</span>})),<span class="keyword">...</span>
                min(x)==0)),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );


            <span class="comment">% LAG</span>
            <span class="comment">% The lag is set to include 6 months of data</span>
            def = array2table([0:5]',<span class="string">'VariableNames'</span>,{<span class="string">'Lag'</span>});
            defmsg = sprintf([<span class="string">'Problem with the Lag Table. Lag table must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with a single variable, "Lag"'</span>]);
            addParameter(p,<span class="string">'Lag'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(istable(x),<span class="keyword">...</span>
                and(all(strcmpi(sort(x.Properties.VariableNames),{<span class="string">'Lag'</span>})),<span class="keyword">...</span>
                all(strcmpi(sort(x.Properties.VariableNames),{<span class="string">'Lag'</span>})))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );


            <span class="comment">% REQTABLE</span>
            defvn = {<span class="string">'Geographies'</span>,<span class="string">'IndustryGroups'</span>,<span class="string">'CollateralGroups'</span>,<span class="string">'LoanSize'</span>,<span class="keyword">...</span>
            	<span class="string">'RiskCategories'</span>,<span class="string">'TermCategories'</span>,<span class="string">'FacilityType'</span>,<span class="string">'Lag'</span>};
            defvt = {<span class="string">'double'</span>,<span class="string">'double'</span>,<span class="string">'double'</span>,<span class="string">'double'</span>,<span class="string">'double'</span>,<span class="string">'double'</span>,<span class="keyword">...</span>
                <span class="string">'double'</span>,<span class="string">'double'</span>};
            def = table(<span class="string">'Size'</span>,[0,length(defvn)],<span class="string">'VariableTypes'</span>,defvt,<span class="string">'VariableNames'</span>,defvn);
            defmsg = sprintf([<span class="string">'Problem with the REQTABLE Table. REQTABLE table must'</span> <span class="keyword">...</span>
                <span class="string">' be a table with appropriate variable names and types'</span>]);
            addParameter(p,<span class="string">'REQTABLE'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(istable(x),<span class="keyword">...</span>
                and(all(strcmpi(sort(x.Properties.VariableNames),defvn)),<span class="keyword">...</span>
                all(strcmpi(sort(x.Properties.VariableNames),defvn))<span class="keyword">...</span>
                )),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );





            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});
            obj.Description = p.Results.Description;
            obj.CreatedOn = p.Results.CreatedOn;
            obj.LoanSize = p.Results.LoanSize;
            obj.RiskCategories = p.Results.RiskCategories;
            obj.TermCategories = p.Results.TermCategories;
            obj.CollateralGroups = p.Results.CollateralGroups;
            obj.IndustryGroups = p.Results.IndustryGroups;
            obj.Geographies = p.Results.Geographies;
            obj.RateType = p.Results.RateType;
            obj.FacilityType = p.Results.FacilityType;
            obj.NewOrRenewal = p.Results.NewOrRenewal;
            obj.Weights = p.Results.Weights;
            obj.Lag = p.Results.Lag;
            obj.REQTABLE = p.Results.REQTABLE;


            <span class="comment">% Create Categoricals property. Categoricals is a table that</span>
            <span class="comment">% indicates which of the dimensions are categorical (as opposed</span>
            <span class="comment">% to those that are continuous).</span>
            obj.Categoricals =array2table(categorical([
            <span class="string">"LoanSize"</span>,<span class="string">"RiskCategories"</span>,<span class="string">"TermCategories"</span>,<span class="string">"Geographies"</span>,<span class="keyword">...</span>
            <span class="string">"CollateralGroups"</span>,<span class="string">"IndustryGroups"</span>,<span class="string">"RateType"</span>,<span class="string">"FacilityType"</span>,<span class="keyword">...</span>
            <span class="string">"NewOrRenewal"</span>,<span class="string">"Lag"</span>]'),<span class="string">'VariableNames'</span>,{<span class="string">'Property'</span>});
            obj.Categoricals.IsCat = logical([0 0 1 1 1 1 1 1 1 0]');


        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = make_REQTABLE(obj)
            <span class="comment">%</span>
            <span class="comment">% Creates the reqtable (the requested table) holds the list of</span>
            <span class="comment">% requested grid "squares", the points for which we will return</span>
            <span class="comment">% an interpolated price.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% Begin with Gegoraphy</span>
            g = obj.Geographies(:,{<span class="string">'Geographies'</span>});

            <span class="comment">% Expand with Industry</span>
            r1 = table();
            industries = obj.IndustryGroups.IndGrpID;
            <span class="keyword">for</span> i = 1:length(industries)
                ind = array2table(repmat(industries(i),size(g,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'IndustryGroups'</span>});
                r1 = [r1;[g,ind]];
            <span class="keyword">end</span>

            <span class="comment">% Expand with Collateral</span>
            r2 = table();
            collIDs = obj.CollateralGroups.SecGID;
            <span class="keyword">for</span> c = 1:length(collIDs)
                colid = array2table(repmat(collIDs(c),size(r1,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'CollateralGroups'</span>});
                r2 = [r2;[r1,colid]];
            <span class="keyword">end</span>


            <span class="comment">% Expand with Loan Size</span>
            T = parseStruct(obj,<span class="string">'LoanSize'</span>);

            r3 = table();
            nloansizes = length(obj.LoanSize.Groups)+1;
            nloansizes = size(T,1);
            loansizeIDs = 1:nloansizes;
            loansizeIDs = T.GroupNum;
            loansizeMPs = T.MidPoint;
            <span class="keyword">for</span> s = 1:nloansizes
                lsid = array2table(repmat(loansizeIDs(s),size(r2,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'LoanSize'</span>});
                lsmp = array2table(log(repmat(loansizeMPs(s),size(r2,1),1)),<span class="string">'VariableNames'</span>,{<span class="string">'LoanSize'</span>});
                <span class="comment">%r3 = [r3;[r2,lsid]];</span>
                r3 = [r3;[r2,lsmp]];
            <span class="keyword">end</span>

            <span class="comment">% Expand with Risk Cat</span>
            r4 = table();
            nriskcats = length(obj.RiskCategories.Groups)+1;
            riskcatIDs = 1:nriskcats;
            <span class="keyword">for</span> c = 1:nriskcats
                rcid = array2table(repmat(riskcatIDs(c),size(r3,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'RiskCategories'</span>});
                r4 = [r4;[r3,rcid]];
            <span class="keyword">end</span>

            <span class="comment">% Expand with Term Cat</span>
            <span class="comment">% Set the maximum term to 30 years</span>
            T = parseStruct(obj,<span class="string">'TermCategories'</span>);

            r5 = table();
            ntermcats = length(obj.TermCategories.Groups)+1;
            ntermcats = size(T,1);
            termcatIDs = 1:ntermcats;
            termcatIDs = T.GroupNum;
            termcatMPs = T.MidPoint;
            <span class="keyword">for</span> t = 1:ntermcats
                tcid = array2table(repmat(termcatIDs(t),size(r4,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'TermCategories'</span>});
                tcmp = array2table(repmat(termcatMPs(t),size(r4,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'TermCategories'</span>});
                <span class="comment">%r5 = [r5;[r4,tcid]];</span>
                r5 = [r5;[r4,tcmp]];
            <span class="keyword">end</span>

            <span class="comment">% Expand with Facility Type</span>
            r6 = table();
            factypes = obj.FacilityType;
            nfactypes = length(factypes);
            <span class="keyword">for</span> f = 1:nfactypes
                ft = array2table(repmat(factypes(f),size(r5,1),1),<span class="string">'VariableNames'</span>,{<span class="string">'FacilityType'</span>});
                r6 = [r6;[r5,ft]];
            <span class="keyword">end</span>

            <span class="comment">% Add Lag</span>
            <span class="comment">% The requested grid always has a zero lag</span>
            r6.Lag = zeros(size(r6,1),1);

            <span class="comment">% output argument</span>
            obj.REQTABLE = r6;


        <span class="keyword">end</span>

        <span class="keyword">function</span> T = parseStruct(obj,dimField)
            <span class="comment">% parseStruct</span>
            <span class="comment">%</span>
            <span class="comment">% parses the structure holding groups in a pricing GRID class object</span>
            <span class="comment">%</span>
            <span class="comment">% returns a table (T) with variables:</span>
            <span class="comment">%   GroupNum: number of the group</span>
            <span class="comment">%   GreaerThan: the lower edge of the group</span>
            <span class="comment">%   LessThan: the upper edge of the group</span>
            <span class="comment">%   MidPoint: the midpoing of the group</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% get the structure holding the min, max and groups</span>
            S = obj.(dimField);


            <span class="comment">% The "extended" vector extends from 0 to the highest value, with interim</span>
            <span class="comment">% values at the grouping levels.</span>
            vec_extended = unique([S.Min, S.Groups, S.Max]);

            <span class="comment">% Use convolution to calculate the midpionts between each of the values in</span>
            <span class="comment">% the extended vector</span>
            vec_midpoints = conv(vec_extended, [0.5 0.5], <span class="string">'valid'</span>);

            <span class="comment">% Create the output table</span>
            T = array2table([[1:length(vec_midpoints)]',<span class="keyword">...</span>
                vec_extended(1:(end-1))',<span class="keyword">...</span>
                vec_extended(2:end)',<span class="keyword">...</span>
                vec_midpoints'],<span class="keyword">...</span>
                <span class="string">'VariableNames'</span>,{<span class="string">'GroupNum'</span>,<span class="string">'GreaterThan'</span>,<span class="string">'LessThan'</span>,<span class="string">'MidPoint'</span>});

        <span class="keyword">end</span>

        <span class="keyword">function</span> outputArg = getGridName(obj)
            <span class="comment">%METHOD1 Summary of this method goes here</span>
            <span class="comment">%   Detailed explanation goes here</span>
            dbstk = dbstack();
            outputArg = dbstk;
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
classdef CLAgrid
    % 
    % CLAgrid
    %
    % CLAgrid is a class object holding the grid information for the CLA 
    % Pricing Interpolation Tool
    %
    %

    properties
        Description         % Description of the grid

        CreatedOn           % Date on which the grid was created

        LoanSize            % A Structure holding information related to loan 
                            % size range and the group splits.

        RiskCategories      % A Structure holding information related to risk 
                            % category range and the group splits.

        TermCategories      % A Structure holding information related to term 
                            % range and the group splits.

        Geographies         %
        CollateralGroups    %
        IndustryGroups      %
        RateType            %
        FacilityType        %
        NewOrRenewal        %

        Weights             %
        Lag                 %

        Categoricals        % Categoricals is a table that indicates which 
                            % of the dimensions are categorical (as opposed
                            % to those that are ordinalt or continuous).

        REQTABLE            % REQ_TABLE is the table holding all of the
                            % grid squares but is UNPOPULATED


    end

    methods
        function obj = CLAgrid(TAXONOMYTABS,varargin)
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %
            % CLAgrid 
            %  Construct an instance of the CLAgrid class object
            %
            %
            %
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % DESCRIPTION
            def = sprintf("CLA Grid created on %s",datetime());
            defmsg = sprintf(['Problem with the grid description input. the ' ...
                'description must be a string']);
            addParameter(p,'Description',def,...
                @(x)...
                assert(isstring(x),...
                defmsg)...
                );


            % CREATEDON
            def = datetime();

            defmsg = sprintf(['Problem with the grid created on input. the ' ...
                'created-on-date (CreatedOn) must be a date']);
            addParameter(p,'CreatedOn',def,...
                @(x)...
                assert(isdatetime(x),...
                defmsg)...
                );

            % LOAN SIZE (LoanSize)
            % Add optional input for LoanSize data structure
            def = struct();
            def.Min = 0;
            def.Max = 100;
            def.Groups = [0.25,0.5,1,5,10,50];
            defmsg = sprintf(['Problem with the LoanSize input. LoanSize must' ...
                ' be a structure with the fields "Min", "Max", and "Groups".' ...
                '  "Groups" must be a row vector, and "Max" must be greater' ...
                ' than "Miin"']);
            addParameter(p,'LoanSize',def,...
                @(x)...
                assert(and(x.Max > x.Min,...
                and(size(x.Groups,1)==1,...
                all(strcmpi(sort(fieldnames(x)),{'Groups';'Max';'Min'})))),...
                defmsg)...
                );

            % RISK CATEGORIES (RiskCategories)
            % Add optional input for LoanSize data structure
            def = struct();
            def.Min = 1;
            def.Max = 12;
            def.Groups = [3,7];
            defmsg = sprintf(['Problem with the Risk Categories input. RiskCategories must' ...
                ' be a structure with the fields "Min", "Max", and "Groups".' ...
                '  "Groups" must be a row vector, and "Max" must be greater' ...
                ' than "Min"']);
            addParameter(p,'RiskCategories',def,...
                @(x)...
                assert(and(x.Max > x.Min,...
                and(size(x.Groups,1)==1,...
                all(strcmpi(sort(fieldnames(x)),{'Groups';'Max';'Min'})))),...
                defmsg)...
                );   
            
            % TERM CATEGORIES (TermCategories)
            % Add optional input for term data structure
            def = struct();
            def.Min = 1;
            def.Max = 120;
            def.Groups = [36,72];
            defmsg = sprintf(['Problem with the Term Categories input. TermCategories must' ...
                ' be a structure with the fields "Min", "Max", and "Groups".' ...
                '  "Groups" must be a row vector, and "Max" must be greater' ...
                ' than "Miin"']);
            addParameter(p,'TermCategories',def,...
                @(x)...
                assert(and(x.Max > x.Min,...
                and(size(x.Groups,1)==1,...
                all(strcmpi(sort(fieldnames(x)),{'Groups';'Max';'Min'})))),...
                defmsg)...
                );    

            % COLLATERAL TYPES (CollateralGroups)
            % Add optional input for Collateral type data
            allCollateralTypeIDs = TAXONOMYTABS.Collateral_Type.Collateral_Type;
            allCollateralTypes = categorical(TAXONOMYTABS.Collateral_Type.Collateral_Type_Name);
            weakCollateralTypes = categorical([...
                "All Assets";
                "Cash and Cash Equivalent";
                "Commercial Vehicles";
                "Consumer Vehicles";
                "Land";
                "Real Estate (residential)"; ...
                "Unsecured"]);
            weakCollateralTypeIDs = allCollateralTypeIDs(ismember(weakCollateralTypes,allCollateralTypes));
            strongCollateralTypes = setdiff(allCollateralTypes,weakCollateralTypes);
            strongCollateralTypeIDs = setdiff(allCollateralTypeIDs,weakCollateralTypeIDs);            
            def = array2table([{...
                'weak',   {weakCollateralTypeIDs}, {weakCollateralTypes};...
                'strong', {strongCollateralTypeIDs}, {strongCollateralTypes}...
                }],'VariableNames',{'SecurityGroup','SecurityCategoryIDs','SecurityTypes'});
            def.SecGID = [1:size(def,1)]';
            def = movevars(def, "SecGID", "Before", "SecurityGroup");
            defmsg = sprintf(['Problem with the Security Key Table. SecurityKeyTable must' ...
                ' be a table with the Variables "SecurityGroup", "SecurityCategoryIDs", and "SecurityTypes".' ...
                '  "Groups" must be a row vector, and "Max" must be greater' ...
                ' than "Miin"']);
            addParameter(p,'CollateralGroups',def, @(x) assert(istable(x), defmsg));


            % INDUSTRIES
            def = defIndustryTab();
            defmsg = sprintf(['Problem with the Industry Table. IndustryTable must' ...
                ' be a table with the Variables "IndGrpID","IndGrpName","NAICS2s","NAICSIndustries".' ...
                ]);            
            addParameter(p,'IndustryGroups',def,...
                @(x)...
                assert(istable(x),...
                defmsg)...
                );

            % GEOGRAPHIES
            % Geographies are stored in a table
            [~ ,def,~] = defGeographyTable(TAXONOMYTABS.LocationDatabase);
            
            % Set the level order (rank) for each of the geographies. The
            % geographies are listed from larger to smaller. Metro/Rural is
            % considered at the level just above MSA.
            defmsg = sprintf(['Problem with the Geography Table. Geography table must' ...
                ' be a table with the Variables "Include","LevelIdVar", "LevelNameVar", and "Rank".' ...
                ]);            
            addParameter(p,'Geographies',def,...
                @(x)...
                assert(and(istable(x),...
                istable(x)),...
                defmsg)...
                );

            % RATE TYPE/INDEX
            % Rate type is a scalar providing the rate/indices for which
            % the grid applies
            def = defRatesTab();
            defmsg = sprintf(['Problem with the Rates Table. Rates table must' ...
                ' be a table with the Variables "Index","USE","IndexIDs","PricingStructureIDs".' ...
                ]); 

            addParameter(p,'RateType',def,...
                @(x)...
                assert(and(istable(x),...
                and(all(strcmpi(sort(x.Properties.VariableNames),{'Index','IndexIDs','PricingStructureIDs','USE'})),...
                all(strcmpi(sort(x.Properties.VariableNames),{'Index','IndexIDs','PricingStructureIDs','USE'})))),...
                defmsg)...
                );

            % FACILITY TYPES
            % facility types is a vector providing the facility types (IDX)
            % for which the grid applies
            def = [1,2];

            sprintf(['Problem with the Facility type ' ...
                '(revolving/non-revolving) selection. The origination type must' ...
                ' be a vector value with a maximum value of 2.' ...
                ]);            
            addParameter(p,'FacilityType',def,...
                @(x)...
                assert(and(isvector(x),max(x)<3),...
                defmsg)...
                );            


            % ORIGINATION TYPES
            % NewOrRenewal is a vector providing the origination types for
            % which the grid applies
            def = [1;2];

            defmsg = sprintf(['Problem with the origination type ' ...
                '(new/renewal) selection. The origination type must' ...
                ' be a vector value with a maximum value of 2.' ...
                ]);            
            addParameter(p,'NewOrRenewal',def,...
                @(x)...
                assert(and(isvector(x),max(x)<3),...
                defmsg)...
                );



            % WEIGHTS
            % Weights (on each of the different dimensions in the grid) are 
            % stored in a weights table
            def = table();
            def.CollateralGroups('Raw')                 = 15;
            def.Geographies('Raw')                      = 15;
            def.LoanSize('Raw')                         = 5;
            def.TermCategories('Raw')                   = 10;
            def.RiskCategories('Raw')                   = 20;
            def.Lag('Raw')                              = 25;
            def.FacilityType('Raw')                     = 5;
            def.IndustryGroups('Raw')                   = 5;
            def('Scaled',:) = def('Raw',:) ./ sum(def{'Raw',:});

            defmsg = sprintf(['Problem with the Weights Table. Weights table must' ...
                ' be a table with the Variables "FacilityType","IndustryGroups","Lag","LoanSize", "Location",' ...
                '"RiskCategories", "CollateralGroups", "TermCategories".' ...
                ]);            
            addParameter(p,'Weights',def,...
                @(x)...
                assert(and(istable(x),...
                and(all(strcmpi(sort(x.Properties.VariableNames),{'FacilityType','Industry','Lag','LoanSize', 'Location','SPRiskGroup', 'Security', 'Term'})),...
                min(x)==0)),...
                defmsg)...
                );


            % LAG
            % The lag is set to include 6 months of data 
            def = array2table([0:5]','VariableNames',{'Lag'});
            defmsg = sprintf(['Problem with the Lag Table. Lag table must' ...
                ' be a table with a single variable, "Lag"']);
            addParameter(p,'Lag',def,...
                @(x)...
                assert(and(istable(x),...
                and(all(strcmpi(sort(x.Properties.VariableNames),{'Lag'})),...
                all(strcmpi(sort(x.Properties.VariableNames),{'Lag'})))),...
                defmsg)...
                );


            % REQTABLE
            defvn = {'Geographies','IndustryGroups','CollateralGroups','LoanSize',...
            	'RiskCategories','TermCategories','FacilityType','Lag'};
            defvt = {'double','double','double','double','double','double',...
                'double','double'};
            def = table('Size',[0,length(defvn)],'VariableTypes',defvt,'VariableNames',defvn);
            defmsg = sprintf(['Problem with the REQTABLE Table. REQTABLE table must' ...
                ' be a table with appropriate variable names and types']);
            addParameter(p,'REQTABLE',def,...
                @(x)...
                assert(and(istable(x),...
                and(all(strcmpi(sort(x.Properties.VariableNames),defvn)),...
                all(strcmpi(sort(x.Properties.VariableNames),defvn))...
                )),...
                defmsg)...
                );




            
            % Parse and set results
            parse(p,varargin{:});
            obj.Description = p.Results.Description;
            obj.CreatedOn = p.Results.CreatedOn;
            obj.LoanSize = p.Results.LoanSize;
            obj.RiskCategories = p.Results.RiskCategories;
            obj.TermCategories = p.Results.TermCategories;
            obj.CollateralGroups = p.Results.CollateralGroups;
            obj.IndustryGroups = p.Results.IndustryGroups;
            obj.Geographies = p.Results.Geographies;
            obj.RateType = p.Results.RateType;
            obj.FacilityType = p.Results.FacilityType;
            obj.NewOrRenewal = p.Results.NewOrRenewal;
            obj.Weights = p.Results.Weights;
            obj.Lag = p.Results.Lag;
            obj.REQTABLE = p.Results.REQTABLE;


            % Create Categoricals property. Categoricals is a table that
            % indicates which of the dimensions are categorical (as opposed
            % to those that are continuous).
            obj.Categoricals =array2table(categorical([ 
            "LoanSize","RiskCategories","TermCategories","Geographies",...
            "CollateralGroups","IndustryGroups","RateType","FacilityType",...    
            "NewOrRenewal","Lag"]'),'VariableNames',{'Property'});
            obj.Categoricals.IsCat = logical([0 0 1 1 1 1 1 1 1 0]');


        end
        
        function obj = make_REQTABLE(obj)
            %
            % Creates the reqtable (the requested table) holds the list of
            % requested grid "squares", the points for which we will return
            % an interpolated price.
            %
            %
            %
            %
            %
            %
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % Begin with Gegoraphy
            g = obj.Geographies(:,{'Geographies'});
            
            % Expand with Industry
            r1 = table();
            industries = obj.IndustryGroups.IndGrpID;
            for i = 1:length(industries)
                ind = array2table(repmat(industries(i),size(g,1),1),'VariableNames',{'IndustryGroups'});
                r1 = [r1;[g,ind]];
            end
            
            % Expand with Collateral
            r2 = table();
            collIDs = obj.CollateralGroups.SecGID;
            for c = 1:length(collIDs)
                colid = array2table(repmat(collIDs(c),size(r1,1),1),'VariableNames',{'CollateralGroups'});
                r2 = [r2;[r1,colid]];
            end
            
            
            % Expand with Loan Size
            T = parseStruct(obj,'LoanSize');
            
            r3 = table();
            nloansizes = length(obj.LoanSize.Groups)+1;
            nloansizes = size(T,1);
            loansizeIDs = 1:nloansizes;
            loansizeIDs = T.GroupNum;
            loansizeMPs = T.MidPoint;
            for s = 1:nloansizes
                lsid = array2table(repmat(loansizeIDs(s),size(r2,1),1),'VariableNames',{'LoanSize'});
                lsmp = array2table(log(repmat(loansizeMPs(s),size(r2,1),1)),'VariableNames',{'LoanSize'});
                %r3 = [r3;[r2,lsid]];
                r3 = [r3;[r2,lsmp]];
            end            
            
            % Expand with Risk Cat
            r4 = table();
            nriskcats = length(obj.RiskCategories.Groups)+1;
            riskcatIDs = 1:nriskcats;
            for c = 1:nriskcats
                rcid = array2table(repmat(riskcatIDs(c),size(r3,1),1),'VariableNames',{'RiskCategories'});
                r4 = [r4;[r3,rcid]];
            end
            
            % Expand with Term Cat
            % Set the maximum term to 30 years
            T = parseStruct(obj,'TermCategories');

            r5 = table();
            ntermcats = length(obj.TermCategories.Groups)+1;
            ntermcats = size(T,1);
            termcatIDs = 1:ntermcats;
            termcatIDs = T.GroupNum;
            termcatMPs = T.MidPoint;
            for t = 1:ntermcats
                tcid = array2table(repmat(termcatIDs(t),size(r4,1),1),'VariableNames',{'TermCategories'});
                tcmp = array2table(repmat(termcatMPs(t),size(r4,1),1),'VariableNames',{'TermCategories'});
                %r5 = [r5;[r4,tcid]];
                r5 = [r5;[r4,tcmp]];
            end
            
            % Expand with Facility Type
            r6 = table();
            factypes = obj.FacilityType;
            nfactypes = length(factypes);
            for f = 1:nfactypes
                ft = array2table(repmat(factypes(f),size(r5,1),1),'VariableNames',{'FacilityType'});
                r6 = [r6;[r5,ft]];
            end
            
            % Add Lag
            % The requested grid always has a zero lag
            r6.Lag = zeros(size(r6,1),1);

            % output argument
            obj.REQTABLE = r6;


        end

        function T = parseStruct(obj,dimField)
            % parseStruct
            %
            % parses the structure holding groups in a pricing GRID class object
            %
            % returns a table (T) with variables:
            %   GroupNum: number of the group
            %   GreaerThan: the lower edge of the group
            %   LessThan: the upper edge of the group
            %   MidPoint: the midpoing of the group
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            
            % get the structure holding the min, max and groups
            S = obj.(dimField);
            
            
            % The "extended" vector extends from 0 to the highest value, with interim
            % values at the grouping levels.
            vec_extended = unique([S.Min, S.Groups, S.Max]);
            
            % Use convolution to calculate the midpionts between each of the values in
            % the extended vector
            vec_midpoints = conv(vec_extended, [0.5 0.5], 'valid');
            
            % Create the output table
            T = array2table([[1:length(vec_midpoints)]',...
                vec_extended(1:(end-1))',...
                vec_extended(2:end)',...
                vec_midpoints'],...
                'VariableNames',{'GroupNum','GreaterThan','LessThan','MidPoint'});

        end

        function outputArg = getGridName(obj)
            %METHOD1 Summary of this method goes here
            %   Detailed explanation goes here
            dbstk = dbstack();
            outputArg = dbstk;
        end
    end
end
##### SOURCE END #####
-->
</body>
</html>
