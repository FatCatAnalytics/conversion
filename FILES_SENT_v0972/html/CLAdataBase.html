<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>CLAdataBase</title>
<meta name="generator" content="MATLAB 24.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2024-12-18">
<meta name="DC.source" content="CLAdataBase.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#3">TERM (IN MONTHS)</a>
</li>
<li>
<a href="#4">LOAN SIZE</a>
</li>
<li>
<a href="#5">Pricing (NaN Pricing)</a>
</li>
<li>
<a href="#6">Remove Obvioiusly Illegal Pricing</a>
</li>
<li>
<a href="#7">Remove 0 Fixed Rates</a>
</li>
<li>
<a href="#8">PRICING (off Market)</a>
</li>
<li>
<a href="#9">Idenfity Likely Outliers (using IQR)</a>
</li>
<li>
<a href="#10">SPREADS to SOFR</a>
</li>
<li>
<a href="#11">SPREADS to PRIME</a>
</li>
<li>
<a href="#12">FIXED RATES</a>
</li>
<li>
<a href="#13">Set DB.H Property</a>
</li>
</ul>
</div>
<pre class="codeinput">
<span class="keyword">classdef</span> CLAdataBase
    <span class="comment">% CLAdataBase</span>
    <span class="comment">%</span>
    <span class="comment">% Detailed explanation goes here</span>
    <span class="comment">%</span>
    <span class="comment">% -------------------------------------------------------------</span>

    <span class="keyword">properties</span>


        Description             <span class="comment">% A string or char description of the</span>
                                <span class="comment">% database</span>


        LoanDataTable           <span class="comment">% A CLAdataTable class ojbect holding the</span>
                                <span class="comment">% Loan level data</span>

        FacilitiesDataTable     <span class="comment">% A CLAdataTable class object holding the</span>
                                <span class="comment">% Facilities level data</span>
                                <span class="comment">% Fields must include:</span>
                                <span class="comment">%   -</span>

        BorrowerVariableDataTable <span class="comment">% A CLAdataTable class object</span>
                                  <span class="comment">% holding the Borrower level data</span>
                                  <span class="comment">% Fields must include:</span>
                                  <span class="comment">%   -</span>

        BorrowerStaticDataTable   <span class="comment">% A CLAdataTable class object</span>
                                  <span class="comment">% holding the Borrower level data</span>
                                  <span class="comment">% Fields must include:</span>
                                  <span class="comment">%   -</span>

        AvailableFileDates  <span class="comment">% A list (vector) of unique file dates</span>
                            <span class="comment">% (dates on which the data were</span>
                            <span class="comment">% assembled and delivered)</span>

        Importer            <span class="comment">% The importer (with much of the data removed</span>
                            <span class="comment">% for space) but will hold the locations of the</span>
                            <span class="comment">% files that hold the raw imported data.</span>


        TaxonomyTabs        <span class="comment">% TaxonomyTabs is a data structure holding</span>
                            <span class="comment">% MATLAB tables.  Each table must be named with</span>
                            <span class="comment">% a variable held in VariableNames. All tables</span>
                            <span class="comment">% in the structure must:</span>
                            <span class="comment">% (1) have only two variables, one with the</span>
                            <span class="comment">% variable ID (named VariableNameID) and the</span>
                            <span class="comment">% other with the translation of the variable ID</span>
                            <span class="comment">% to a categorical variable.</span>
                            <span class="comment">% (2) IDs must be numeric and be limited to the</span>
                            <span class="comment">% numbers held in the DataMat under the</span>
                            <span class="comment">% variable named in the table</span>

         H                  <span class="comment">% Historical table generated by gimmeCleanHist</span>
                            <span class="comment">% holding the historical data. If generated by</span>
                            <span class="comment">% gimmeCleanHist, also is cleaned and holds</span>
                            <span class="comment">% certain transformed fields.</span>


    <span class="keyword">end</span>

    <span class="keyword">methods</span>
        <span class="keyword">function</span> DB = CLAdataBase(LoanDataTable, FacilitiesDataTable, <span class="keyword">...</span>
                BorrowerVariableDataTable, BorrowerStaticDataTable)
            <span class="comment">% CLAdataBase</span>
            <span class="comment">%</span>
            <span class="comment">% Build an instance of a CLAdataBase class object</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% Set Data Table Properties</span>
            DB.LoanDataTable = LoanDataTable;
            DB.FacilitiesDataTable = FacilitiesDataTable;
            DB.BorrowerVariableDataTable = BorrowerVariableDataTable;
            DB.BorrowerStaticDataTable = BorrowerStaticDataTable;

            <span class="comment">% Set AvailableFileDates property (a full list of all</span>
            <span class="comment">% available File Dates). Note that static data does</span>
            <span class="comment">% not have processing date keys (because it is static), so we</span>
            <span class="comment">% do not need to pull out the dates from</span>
            <span class="comment">% BorrowerStaticDataTable</span>
            DB.AvailableFileDates = getFileDates(LoanDataTable,FacilitiesDataTable,BorrowerVariableDataTable);

            <span class="comment">% Create TaxonomyTabs data structure (concatenation of each of</span>
            <span class="comment">% the individual TaxonomyTabs data structures from the database</span>
            <span class="comment">% components</span>
            TT = struct();
            fieldnamesl = fieldnames(LoanDataTable.TaxonomyTabs);

            <span class="keyword">for</span> l = 1:length(fieldnamesl)
                fn = fieldnamesl{l};
                TT.(char(fn)) = LoanDataTable.TaxonomyTabs.(char(fn));
            <span class="keyword">end</span>

            fieldnamesf = fieldnames(FacilitiesDataTable.TaxonomyTabs);
            <span class="keyword">for</span> f = 1:length(fieldnamesf)
                fn = fieldnamesf{f};
                TT.(char(fn)) = FacilitiesDataTable.TaxonomyTabs.(char(fn));
            <span class="keyword">end</span>


            fieldnamesb = fieldnames(BorrowerVariableDataTable.TaxonomyTabs);
            <span class="keyword">for</span> b = 1:length(fieldnamesb)
                fn = fieldnamesb{b};
                TT.(char(fn)) = BorrowerVariableDataTable.TaxonomyTabs.(char(fn));
            <span class="keyword">end</span>

            fieldnamess = fieldnames(BorrowerStaticDataTable.TaxonomyTabs);
            <span class="keyword">for</span> s = 1:length(fieldnamess)
                fn = fieldnamess{s};
                TT.(char(fn)) = BorrowerStaticDataTable.TaxonomyTabs.(char(fn));
            <span class="keyword">end</span>

            DB.TaxonomyTabs = TT;

        <span class="keyword">end</span>

        <span class="keyword">function</span> DB = updateDB(DB,IMP)
            <span class="comment">%</span>
            <span class="comment">%   UPDATE</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>


            <span class="comment">% VARIABLE DATA -----------------------------------------------</span>
            <span class="comment">% Variable data is updated on a month by month basis. So each</span>
            <span class="comment">% month comes in from either the input data or the existing</span>
            <span class="comment">% data (it cannot be mixed).</span>

            <span class="comment">% Set Import Files</span>
            LOANDataTable = IMP.LOAN_updt;
            FACILITIESDataTable = IMP.FACILITIES_updt;
            BORROWERVariableDataTable = IMP.BORROWERV_updt;
            BORROWERStaticDataTable = IMP.BORROWERS_updt;
            Overwrite = IMP.Overwrite;

            <span class="comment">% Get UpdtFileDates</span>
            <span class="comment">% Find New Dates for Dated data. If the user selected to</span>
            <span class="comment">% overwrite, the update file dates will be the same as the New</span>
            <span class="comment">% File Dates. Otherwise, the update file dates will only be the</span>
            <span class="comment">% file dates that do not currently have data in the database.</span>
            NewFileDates = getFileDates(LOANDataTable,FACILITIESDataTable,BORROWERVariableDataTable);
            CurFileDates = DB.AvailableFileDates;

            <span class="keyword">if</span> Overwrite
                UpdtFileDates = NewFileDates;
            <span class="keyword">else</span>
                idx_newFDonly = ~ismember(NewFileDates,CurFileDates);
                UpdtFileDates = NewFileDates(idx_newFDonly);
            <span class="keyword">end</span>

            <span class="comment">% Update Facilities Data</span>
            facilitiesDatatoAdd = FACILITIESDataTable.GimmeCLAmatrix(<span class="string">"ALL"</span>,<span class="string">'DateList'</span>,UpdtFileDates);
            assignin(<span class="string">"base"</span>,<span class="string">"facilitiesDatatoAdd"</span>,facilitiesDatatoAdd)
            assignin(<span class="string">"base"</span>,<span class="string">"datamat"</span>,DB.FacilitiesDataTable.DataMat)
            DB.FacilitiesDataTable.DataMat = [DB.FacilitiesDataTable.DataMat;facilitiesDatatoAdd];


            <span class="comment">% Update Loan Data</span>
            loanDatatoAdd = LOANDataTable.GimmeCLAmatrix(<span class="string">"ALL"</span>,<span class="string">'DateList'</span>,UpdtFileDates);
            DB.LoanDataTable.DataMat = [DB.LoanDataTable.DataMat; loanDatatoAdd];

            <span class="comment">% Update Borrower Variable Data</span>
            borrowervDatatoAdd = BORROWERVariableDataTable.GimmeCLAmatrix(<span class="string">"ALL"</span>,<span class="string">'DateList'</span>,UpdtFileDates);
            DB.BorrowerVariableDataTable.DataMat = [DB.BorrowerVariableDataTable.DataMat; borrowervDatatoAdd];


            <span class="comment">% AvailableFileDates PROPERTY ---------------------------------</span>
            <span class="comment">% Once we have changed the variable data (added file dates), we</span>
            <span class="comment">% need to update the AvailableFileDates property to reflect the</span>
            <span class="comment">% additional file dates</span>
            DB.AvailableFileDates = getFileDates(DB.LoanDataTable,<span class="keyword">...</span>
                DB.FacilitiesDataTable,DB.BorrowerVariableDataTable);


            <span class="comment">% STATIC DATA -------------------------------------------------</span>
            <span class="comment">% The borrower static data doesn't change from month to month,</span>
            <span class="comment">% so (depending on if we are overwriting) we only identify</span>
            <span class="comment">% borrowers that do not exist in the current borrower static</span>
            <span class="comment">% data. Everything is keyed off of borrower_ID</span>

            <span class="comment">% Get UpdtBIDs</span>
            <span class="comment">% Identify the borrower IDs that we will be updating</span>
            newBIDs = BORROWERStaticDataTable.GimmeCLAmatrix(<span class="string">"borrower_ID"</span>);
            curBIDs = DB.BorrowerStaticDataTable.GimmeCLAmatrix(<span class="string">"borrower_ID"</span>);

            <span class="keyword">if</span> Overwrite
                updBIDs = newBIDs;
            <span class="keyword">else</span>
                idx_newBIDonly = ~ismember(newBIDs,curBIDs);
                updBIDs = newBIDs(idx_newBIDonly);
            <span class="keyword">end</span>

            idx_BDtoAdd = ismember(BORROWERStaticDataTable.GimmeCLAmatrix(<span class="string">"borrower_ID"</span>),updBIDs);
            BDtoAdd = BORROWERStaticDataTable.DataMat(idx_BDtoAdd,:);
            DB.BorrowerStaticDataTable.DataMat = [DB.BorrowerStaticDataTable.DataMat;BDtoAdd];




        <span class="keyword">end</span>

        <span class="keyword">function</span> [DB,clean_diagnostics] = gimmeCleanHist(DB,YearTreasury,varargin)
</pre>
<pre class="codeinput">            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>


            <span class="comment">% Get optional Parameters</span>
            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% Term</span>
            def = <span class="string">'actual'</span>;
            defmsg = sprintf([<span class="string">'Problem with the TermType input. the '</span> <span class="keyword">...</span>
                <span class="string">'TermType input must be a string or char and must be equal '</span> <span class="keyword">...</span>
                <span class="string">'either to "actual" or "estimated"'</span>]);
            addParameter(p,<span class="string">'TermType'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(or(isstring(x),ischar(x)),<span class="keyword">...</span>
                or(strcmpi(x,<span class="string">'actual'</span>),strcmpi(x,<span class="string">'estimated'</span>))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% YearTreasury</span>


            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});
            termtype = p.Results.TermType;

            <span class="comment">% Calcualte Single Pricing IDs</span>
            <span class="comment">%[TAB,SPIDdups] = GimmeCLAHistTab(DB);</span>



            <span class="comment">% Get the untransformed, uncleaned historical data</span>
            H = GimmeCLAHistTab(DB);
</pre>
<h2 id="3">TERM (IN MONTHS)</h2>
<p>Remove facility data with NaN Effective Date, or NaN Maturity Date, or Effective Date greater than Maturity Date</p>
<pre class="codeinput">            <span class="comment">% Calculate the Term</span>
            H.TermMonths = split(between(<span class="keyword">...</span>
                datetime(H.F_Facility_Effective_Date,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>),<span class="keyword">...</span>
                datetime(H.F_Facility_Maturity_Date,<span class="string">'ConvertFrom'</span>,<span class="string">'datenum'</span>),<span class="keyword">...</span>
                <span class="string">'months'</span>),<span class="string">'months'</span>);

            <span class="comment">% Create Estimated Term Field</span>
            H.Term_Estimated = H.TermMonths;
            H.Term_Estimated(isnan(H.Term_Estimated)) = mode(H.TermMonths(H.TermMonths&gt;3));


            <span class="comment">% Identify Negative or NaN term</span>
            <span class="keyword">if</span> strcmpi(termtype,<span class="string">'estimated'</span>)
                fprintf(<span class="string">'cleanhist estimated.\n'</span>)
                idx_NegativeOrNaNTerm = or(isnan(H.Term_Estimated),H.Term_Estimated&lt;1);
            <span class="keyword">else</span>
                idx_NegativeOrNaNTerm = or(isnan(H.TermMonths),H.TermMonths&lt;1);
            <span class="keyword">end</span>

            clean_diagnostics.BadLoanData_BadTerm = H(idx_NegativeOrNaNTerm,:);
            clean_diagnostics.BadLoanData_BadTerm.Properties.Description = <span class="keyword">...</span>
                [<span class="string">'Facility data with errors in the term, either NaN effective date, '</span> <span class="keyword">...</span>
                <span class="string">'maturity date or negative term.'</span>];

            <span class="comment">% Clean Data</span>
            <span class="comment">% if term is less than zero, we set term to NaN (which will cause the</span>
            <span class="comment">% distance along the term dimension to be set to 1 (maximum)).</span>
            H.TermMonths(idx_NegativeOrNaNTerm) = NaN;

            <span class="comment">% If term is greater than 30 years (360 months), remove the loan</span>
            idx_TermMoreThan30years = H.TermMonths &gt; 360;
            clean_diagnostics.TermMoreThan30Years = H(idx_TermMoreThan30years,:);
            H = H(~idx_TermMoreThan30years,:);
</pre>
<h2 id="4">LOAN SIZE</h2>
<p>Loans with a commitment amount greater than 250MM will be excluded from the data set</p>
<pre class="codeinput">            idx_CommitOver250MM = H.F_Commitment_Amount &gt; 250000000;
            clean_diagnostics.CommitOver250MM = H(idx_CommitOver250MM,:);
            H = H(~idx_CommitOver250MM,:);
</pre>
<h2 id="5">Pricing (NaN Pricing)</h2>
<p>Remove fixed rate loans with NaN fixed rate, and remove floating rate loans with NaN spreads</p>
<pre class="codeinput">            idx_FixRateNaNRate = and(H.L_pricing_structure == 1, isnan(H.L_interest_rate_percent));
            clean_diagnostics.FixRateNanRate = H(idx_FixRateNaNRate,:);
            H = H(~idx_FixRateNaNRate,:);

            idx_FlRateNaNSpr = and(H.L_pricing_structure == 2, isnan(H.L_spread_bps));
            clean_diagnostics.FlRateNaNSpr = H(idx_FlRateNaNSpr,:);
            H = H(~idx_FlRateNaNSpr,:);
</pre>
<h2 id="6">Remove Obvioiusly Illegal Pricing</h2>
<p>Spreads of more than 50% removed</p>
<pre class="codeinput">            idx_illegal = or(and(H.L_pricing_structure == 2,H.L_spread_bps&gt;5000),<span class="keyword">...</span>
                and(H.L_pricing_structure == 1,H.L_interest_rate_percent&gt;50));
            clean_diagnostics.ObviouslyIllegal = H(idx_illegal,:);
            H = H(~idx_illegal,:);
</pre>
<h2 id="7">Remove 0 Fixed Rates</h2>
<pre class="codeinput">            idx_zeroFixed = and(H.L_pricing_structure == 1, H.L_interest_rate_percent&lt;0.00001);
            clean_diagnostics.ZeroFixed = H(idx_zeroFixed,:);
            H = H(~idx_zeroFixed,:);
</pre>
<h2 id="8">PRICING (off Market)</h2>
<p>From Ryan: It looks like Fifth Third (bank 3), Business Banking (LOB 8), Term Loans (Loan Type 2) are the large majority of rates under 5% (an approximation of the 1 Year Treasury for 2023). Without this population, the number of low rates decreases drastically.</p>
<p>Any loans with Bank_ID == 3, Line_of_Business == 8, AND Loan_Type ==2 will be considered excluded from the IQR range, but will be included in the data set as long as it survives the other tests.</p>
<p>All loans in a facility that includes the pricing fallilng outside of the IQR will be removed. This is for two reasons (1) practical: we can't use the loanID since loan IDs are not unique across banks, and (2) it is reasonable to belive that other pricing within a faciilty may be off market to either "make up" for artificially low spreads, or if one is erroneous, others may be too.</p>
<pre class="codeinput">            <span class="comment">% Add field to H table indicating whether the loan will be inclueed in the</span>
            <span class="comment">% IQR calculation</span>
            idx_FifthThird = H.L_Bank_ID == 3;
            idx_LOB = H.L_Line_of_Business == 8;
            idx_Term = H.L_Loan_Type == 2;
            idx_notInIQR  = all([idx_FifthThird,idx_LOB,idx_Term],2);
            clean_diagnostics.excludedFromIQR = H(idx_notInIQR,:);
            H.notInIQR = idx_notInIQR;
            fprintf(<span class="string">"%.0f loans marked outside of IQR calculation.\n"</span>,sum(H.notInIQR))
</pre>
<h2 id="9">Idenfity Likely Outliers (using IQR)</h2>
<p>Loop through each month and calculate the monthly IQR (excluding non-IQR data), then identify all of the loans (using Loan Price ID) that will be removed for being more than the threshold IQRs from the mean.</p>
<pre class="codeinput">            fdsavailable = DB.AvailableFileDates;
            badSprSOFRFids = [];
            badSprPRIMEFids = [];
            badFixedFids = [];


            <span class="keyword">for</span> m = 1:length(fdsavailable)
                mth = fdsavailable(m);
                M = H(H.L_file_date == mth,:);

                <span class="comment">% Set up plot</span>
                <span class="comment">%figure('Position',[100 100 1070 500])</span>
</pre>
<h2 id="10">SPREADS to SOFR</h2>
<pre class="codeinput">                idx_SOFR = and(and(M.L_Index&gt;=103,M.L_Index&lt;=109),M.L_pricing_structure == 2);
                MFL_SOFR = M(idx_SOFR,:);
                [r_spr,q_spr] = iqr(MFL_SOFR.L_spread_bps(~MFL_SOFR.notInIQR),<span class="string">"all"</span>);
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*1.5;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_SOFR.L_spread_bps&gt;maxSPR;
                idx_SPRtooLow_m = MFL_SOFR.L_spread_bps&lt;minSPR;
                badSprSOFRFids = [badSprSOFRFids;MFL_SOFR.L_Facility_ID(idx_SPRtooHigh_m);MFL_SOFR.L_Facility_ID(idx_SPRtooLow_m)];

                <span class="comment">%subplot(1,3,1)</span>
                <span class="comment">%h = histogram(MFL_SOFR.L_spread_bps);</span>
                <span class="comment">%tit = sprintf('Spreads to SOFR\n%s',...</span>
                <span class="comment">%    strcat(num2str(month(mth)),"-",num2str(year(mth))));</span>
                <span class="comment">%title(tit)</span>
                <span class="comment">%binwidth = h.BinWidth;</span>
                <span class="comment">%hold on</span>
                <span class="comment">%idx_excludeSPR = ismember(MFL_SOFR.L_Facility_ID,badSprSOFRFids);</span>
                <span class="comment">%histogram(MFL_SOFR.L_spread_bps(~idx_excludeSPR),'BinWidth',binwidth)</span>
                <span class="comment">%tit = sprintf('Spreads to SOFR\n%s',...</span>
                <span class="comment">%    strcat(num2str(month(mth)),"-",num2str(year(mth))));</span>
                <span class="comment">%title(tit)</span>
                <span class="comment">%legend({'All Observations','Excluding Outliers'},...</span>
                <span class="comment">%    'Location','southoutside')</span>
                <span class="comment">%hold off</span>
</pre>
<h2 id="11">SPREADS to PRIME</h2>
<pre class="codeinput">                idx_PRIME = and(and(M.L_Index&gt;=10,M.L_Index&lt;=14),M.L_pricing_structure == 2);
                MFL_PRIME = M(idx_PRIME,:);
                [r_spr,q_spr] = iqr(MFL_PRIME.L_spread_bps(~MFL_PRIME.notInIQR),<span class="string">"all"</span>);
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*nIQRs;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_PRIME.L_spread_bps&gt;maxSPR;
                idx_SPRtooLow_m = MFL_PRIME.L_spread_bps&lt;minSPR;
                badSprPRIMEFids = [badSprPRIMEFids;MFL_PRIME.L_Facility_ID(idx_SPRtooHigh_m);MFL_PRIME.L_Facility_ID(idx_SPRtooLow_m)];

                <span class="comment">%subplot(1,3,2)</span>
                <span class="comment">%h = histogram(MFL_PRIME.L_spread_bps);</span>
                <span class="comment">%binwidth = h.BinWidth;</span>
                <span class="comment">%tit = sprintf('Spread to PRIME\n%s',...</span>
                <span class="comment">%    strcat(num2str(month(mth)),"-",num2str(year(mth))));</span>
                <span class="comment">%title(tit)</span>
                <span class="comment">%hold on</span>
                <span class="comment">%idx_excludeSPRPRIME = ismember(MFL_PRIME.L_Facility_ID,badSprPRIMEFids);</span>
                <span class="comment">%histogram(MFL_PRIME.L_spread_bps(~idx_excludeSPRPRIME),'BinWidth',binwidth);</span>
                <span class="comment">%legend({'All Observations','Excluding Outliers'},...</span>
                <span class="comment">%    'Location','southoutside')</span>
                <span class="comment">%hold off</span>
</pre>
<h2 id="12">FIXED RATES</h2>
<pre class="codeinput">                MFX = M(M.L_pricing_structure == 1,:);
                [r_fix,q_fix] = iqr(MFX.L_interest_rate_percent(~MFX.notInIQR),<span class="string">"all"</span>);
                nIQRs = 1;
                maxFIX = q_fix(2)+r_fix*nIQRs;
                minFIX = q_fix(1)-r_fix*nIQRs;
                idx_FIXtooHigh_m = MFX.L_interest_rate_percent&gt;maxFIX;
                idx_FIXtooLow_m = MFX.L_interest_rate_percent&lt;minFIX;
                badFixedFids = [badFixedFids;MFX.L_Facility_ID(idx_FIXtooHigh_m);MFX.L_Facility_ID(idx_FIXtooLow_m)];

                <span class="comment">% Hard limit using treasuries</span>
                Tmonth = mean(YearTreasury.DGS1(YearTreasury.MONTH == mth));
                TmonthMin = 0.75 .* Tmonth;

                <span class="comment">%subplot(1,3,3)</span>
                <span class="comment">%h = histogram(MFX.L_interest_rate_percent);</span>
                <span class="comment">%binwidth = h.BinWidth;</span>
                <span class="comment">%tit = sprintf('Fixed Rate\n%s',...</span>
                <span class="comment">%    strcat(num2str(month(mth)),"-",num2str(year(mth))));</span>
                <span class="comment">%title(tit)</span>
                <span class="comment">%hold on</span>

                idx_excludeFIX = ismember(MFX.L_Facility_ID,badFixedFids);

                <span class="comment">%histogram(MFX.L_interest_rate_percent(~idx_excludeFIX),'BinWidth',binwidth)</span>
                <span class="comment">%tit = sprintf('Fixed Rate\n(IQR: %.4f, Max: %.2f, Min: %.2f)\n%s',...</span>
                <span class="comment">%    (q_fix(2) - q_fix(1)),maxFIX, minFIX,strcat(num2str(month(mth)),"-",num2str(year(mth))));</span>
                <span class="comment">%title(tit)</span>
                <span class="comment">%</span>
                <span class="comment">%hold on</span>
                <span class="comment">%yl = ylim();</span>
                <span class="comment">%plot([TmonthMin,TmonthMin],[0,yl(2)])</span>
                <span class="comment">%legend({'All Observations','Excluding Outliers','.75 of US Treasury (1year)'},...</span>
                <span class="comment">%    'Location','southoutside')</span>
                <span class="comment">%hold off</span>



            <span class="keyword">end</span>

            idx_badSpreads = ismember(H.PriceDecisionID,badSprSOFRFids);
            clean_diagnostics.SPRtooHighOrtooLow = H(idx_badSpreads,:);
            H = H(~idx_badSpreads,:);

            idx_badFixed = ismember(H.PriceDecisionID,badFixedFids);
            clean_diagnostics.FIXtooHighortooLow = H(idx_badFixed,:);
            H = H(~idx_badFixed,:);
</pre>
<h2 id="13">Set DB.H Property</h2>
<pre class="codeinput">            DB.H = H;
</pre>
<pre class="codeinput">        <span class="keyword">end</span>

        <span class="keyword">function</span> DB = swapToLIBOR(DB,SI,varargin)
            <span class="comment">% SwapToLibor</span>
            <span class="comment">%</span>
            <span class="comment">% Swaps fixed rate loans to LIBOR (in Loans Table)</span>
            <span class="comment">% Stores unswapped rate as UnswappedSPR</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>

            <span class="comment">% Get optional Parameters</span>
            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% Term</span>
            def = <span class="string">'actual'</span>;
            defmsg = sprintf([<span class="string">'Problem with the TermType input. the '</span> <span class="keyword">...</span>
                <span class="string">'TermType input must be a string or char and must be equal '</span> <span class="keyword">...</span>
                <span class="string">'either to "actual" or "estimated"'</span>]);
            addParameter(p,<span class="string">'TermType'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(or(isstring(x),ischar(x)),<span class="keyword">...</span>
                or(strcmpi(x,<span class="string">'actual'</span>),strcmpi(x,<span class="string">'estimated'</span>))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});
            termtype = p.Results.TermType;


            <span class="comment">% Check that the swap Importer has a Libor Table</span>
            <span class="keyword">if</span> isempty(SI.LIBOR)
                msg = sprintf(<span class="string">"missing swap data.\n"</span>);
                error(msg)
            <span class="keyword">end</span>

            <span class="comment">% Check that the swap Importer has a LIBOR Table</span>
            <span class="keyword">if</span> isempty(SI.LIBOR)
                msg = sprintf(<span class="string">"missing swap data.\n"</span>);
                error(msg)
            <span class="keyword">end</span>

            <span class="comment">% Check that the history has been generated</span>
            <span class="keyword">if</span> isempty(DB.H)
                msg = sprintf(<span class="string">'missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n'</span>);
                error(msg)
            <span class="keyword">end</span>

            <span class="comment">% Check that history has been cleaned</span>
            <span class="keyword">if</span> ~ismember(<span class="string">'notInIQR'</span>,DB.H.Properties.VariableNames)
                msg = sprintf(<span class="string">'missing certain historical data fields. Please run gimmeCleanHist then swap.\n'</span>);
                error(msg)
            <span class="keyword">end</span>


            <span class="comment">% Set inputs</span>
            SWAPS = SI.LIBOR;
            LOANS = DB.H;


            <span class="comment">% Initialize Output Series</span>
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);


            <span class="keyword">for</span> l = 1:size(LOANS,1)

                <span class="comment">% Get the Date of the swap. Start by finding the file date of the loan,</span>
                <span class="comment">% then, if that date has swap data, use that date, otherwise, find the</span>
                <span class="comment">% closest date.</span>
                loanDate = LOANS.L_file_date(l);
                <span class="keyword">if</span> ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                <span class="keyword">else</span>
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                <span class="keyword">end</span>

                <span class="comment">% Get the row of the swap (associated with the date)</span>
                idx_swaprow = SWAPS.SWAPDATE == swapdate;

                <span class="keyword">if</span> sum(idx_swaprow) == 1

                    <span class="comment">% Get the column of the swap table (associated with the swap tenor</span>
                    <span class="comment">% Use the term of the loan to identify Which Swap Series we are Looking</span>
                    <span class="comment">% for</span>
                    <span class="keyword">if</span> strcmpi(termtype,<span class="string">'estimated'</span>)
                        swapvarn = strcat(<span class="string">"LIBORSWAP_"</span>,num2str(LOANS.Term_Estimated(l)));
                    <span class="keyword">else</span>
                        swapvarn = strcat(<span class="string">"LIBORSWAP_"</span>,num2str(LOANS.TermMonths(l)));
                    <span class="keyword">end</span>

                    <span class="comment">% If there the swap variable name is valid (term of the loan</span>
                    <span class="comment">% reflects a swap value), return the swap rate</span>
                    <span class="keyword">if</span> ismember(swapvarn,SWAPS.Properties.VariableNames)
                        <span class="comment">% Return the swap rate</span>
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    <span class="keyword">else</span>
                        <span class="comment">% bad swap tenor error</span>
                        swapRateERR(l) = swapRateERR(l)+10;
                    <span class="keyword">end</span>

                <span class="keyword">else</span>
                    <span class="comment">% bad swap date error</span>
                    swapRateERR(l) = swapRateERR(l)+1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Add Swap Rate to Table</span>
            LOANS.SwapRate_LIBOR =  swapRate;

            <span class="comment">% Add Error Series to TAble</span>
            LOANS.SwapErrorKey = swapRateERR;

            <span class="comment">% Store Unswapped spreads</span>
            LOANS.UnswappedSPR = LOANS.L_spread_bps;

            <span class="comment">% Store Swapped Spread</span>
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_LIBOR(idx_fixed);
            DB.H = LOANS;

        <span class="keyword">end</span>

        <span class="keyword">function</span> DB = swapToSOFR(DB,SI,varargin)
            <span class="comment">% SwapToSOFR</span>
            <span class="comment">%</span>
            <span class="comment">% Swaps fixed rate loans to SOFR (in Loans Table)</span>
            <span class="comment">% Stores unswapped rate as UnswappedSPR</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>


            <span class="comment">% Get optional Parameters</span>
            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% Term</span>
            def = <span class="string">'actual'</span>;
            defmsg = sprintf([<span class="string">'Problem with the TermType input. the '</span> <span class="keyword">...</span>
                <span class="string">'TermType input must be a string or char and must be equal '</span> <span class="keyword">...</span>
                <span class="string">'either to "actual" or "estimated"'</span>]);
            addParameter(p,<span class="string">'TermType'</span>,def,<span class="keyword">...</span>
                @(x)<span class="keyword">...</span>
                assert(and(or(isstring(x),ischar(x)),<span class="keyword">...</span>
                or(strcmpi(x,<span class="string">'actual'</span>),strcmpi(x,<span class="string">'estimated'</span>))),<span class="keyword">...</span>
                defmsg)<span class="keyword">...</span>
                );

            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});
            termtype = p.Results.TermType;

            <span class="comment">% Check that the swap Importer has a SOFR Table</span>
            <span class="keyword">if</span> isempty(SI.SOFR)
                msg = sprintf(<span class="string">"missing swap data.\n"</span>);
                error(msg)
            <span class="keyword">end</span>

            <span class="comment">% Check that the history has been generated</span>
            <span class="keyword">if</span> isempty(DB.H)
                msg = sprintf(<span class="string">'missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n'</span>);
                error(msg)
            <span class="keyword">end</span>

            <span class="comment">% Check that history has been cleaned</span>
            <span class="keyword">if</span> ~ismember(<span class="string">'notInIQR'</span>,DB.H.Properties.VariableNames)
                msg = sprintf(<span class="string">'missing certain historical data fields. Please run gimmeCleanHist then swap.\n'</span>);
                error(msg)
            <span class="keyword">end</span>



            <span class="comment">% Set inputs</span>
            SWAPS = SI.SOFR;
            LOANS = DB.H;


            <span class="comment">% Initialize Output Series</span>
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);



            <span class="keyword">for</span> l = 1:size(LOANS,1)

                <span class="comment">% Get the Date of the swap. Start by finding the file date of the loan,</span>
                <span class="comment">% then, if that date has swap data, use that date, otherwise, find the</span>
                <span class="comment">% closest date.</span>
                loanDate = LOANS.L_file_date(l);
                <span class="keyword">if</span> ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                <span class="keyword">else</span>
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                <span class="keyword">end</span>

                <span class="comment">% Get the row of the swap (associated with the date)</span>
                idx_swaprow = SWAPS.SWAPDATE == swapdate;

                <span class="keyword">if</span> sum(idx_swaprow) == 1

                    <span class="comment">% Get the column of the swap table (associated with the swap tenor</span>
                    <span class="comment">% Use the term of the loan to identify Which Swap Series we are Looking</span>
                    <span class="comment">% for</span>
                    <span class="keyword">if</span> strcmpi(termtype,<span class="string">'estimated'</span>)
                        swapvarn = strcat(<span class="string">"SOFRSWAP_"</span>,num2str(LOANS.Term_Estimated(l)));
                    <span class="keyword">else</span>
                        swapvarn = strcat(<span class="string">"SOFRSWAP_"</span>,num2str(LOANS.TermMonths(l)));
                    <span class="keyword">end</span>

                    <span class="comment">% If there the swap variable name is valid (term of the loan</span>
                    <span class="comment">% reflects a swap value), return the swap rate</span>
                    <span class="keyword">if</span> ismember(swapvarn,SWAPS.Properties.VariableNames)
                        <span class="comment">% Return the swap rate</span>
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    <span class="keyword">else</span>
                        <span class="comment">% bad swap tenor error</span>
                        swapRateERR(l) = swapRateERR(l)+10;
                    <span class="keyword">end</span>

                <span class="keyword">else</span>
                    <span class="comment">% bad swap date error</span>
                    swapRateERR(l) = swapRateERR(l)+1;
                <span class="keyword">end</span>
            <span class="keyword">end</span>


            <span class="comment">% Add Swap Rate to Table</span>
            LOANS.SwapRate_SOFR =  swapRate;

            <span class="comment">% Add Error Series to TAble</span>
            LOANS.SwapErrorKey = swapRateERR;

            <span class="comment">% Store Unswapped spreads</span>
            LOANS.UnswappedSPR = LOANS.L_spread_bps;

            <span class="comment">% Store Swapped Spread</span>
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_SOFR(idx_fixed);
            DB.H = LOANS;


        <span class="keyword">end</span>

        <span class="keyword">function</span> [MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate)

            <span class="comment">% GimmeCLAMat</span>
            <span class="comment">%</span>
            <span class="comment">% Returns matrix data from the CLA Database</span>
            <span class="comment">% Returns full matrix for a specific filedate</span>
            <span class="comment">% FileDate must be in datenumber format</span>
            <span class="comment">%</span>
            <span class="comment">% This funciton is the basis for building the table returned in</span>
            <span class="comment">% GimmeCLATable.</span>
            <span class="comment">%</span>
            <span class="comment">% This function is the basis for building the historical matrix</span>
            <span class="comment">% and table returned in GimmeCLAHist</span>
            <span class="comment">% -------------------------------------------------------------</span>
            diagnostics = struct();

            <span class="comment">% Check that File Date is available</span>
            <span class="keyword">if</span> ~ismember(FileDate,DB.AvailableFileDates)
                msg = sprintf(<span class="string">'File date %.0f, not found in list of available dates.\n'</span>,FileDate);
                error(msg)
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel(FileDate)&gt;1
                msg = sprintf(<span class="string">'FileDate must be a single date, not a vector or a range.\n'</span>);
                error(msg);
            <span class="keyword">end</span>

            <span class="comment">% VARIABLE DATA -----------------------------------------------</span>
            <span class="comment">% Get all the Variable Data (Loans, Facility,and Borrower),</span>
            <span class="comment">% associated with the specific filedate</span>

            <span class="comment">% Start with the loan data, set the 'L' table to hold all loan</span>
            <span class="comment">% data from the specific file date.</span>
            idx_fd_L = DB.LoanDataTable.GimmeCLAmatrix(<span class="string">"file_date"</span>) == FileDate;
            L = DB.LoanDataTable.DataMat(idx_fd_L,:);
            VariableNames = DB.LoanDataTable.VariableNames;
            VariableNames_L = cellstr(strcat(<span class="string">"L_"</span>,VariableNames));
            <span class="keyword">if</span> size(L,1)&lt;1
                errormsg = sprintf(<span class="string">'cannot find Loan data associated with the file date.\n'</span>);
                error(errormsg)
            <span class="keyword">end</span>
            diagnostics.L = L;
            assignin(<span class="string">"base"</span>,<span class="string">"L"</span>,array2table(L,<span class="string">"VariableNames"</span>,VariableNames_L))


            <span class="comment">% Set the F table to hold all of the Facilities data from the</span>
            <span class="comment">% specific file date.</span>
            idx_fd_F = DB.FacilitiesDataTable.GimmeCLAmatrix(<span class="string">"file_date"</span>) == FileDate;
            F = DB.FacilitiesDataTable.DataMat(idx_fd_F,:);
            VariableNames = DB.FacilitiesDataTable.VariableNames;
            VariableNames_F = cellstr(strcat(<span class="string">"F_"</span>,VariableNames));
            <span class="keyword">if</span> size(F,1)&lt;1
                errormsg = sprintf(<span class="string">'cannot find Facility data associated with the file date.\n'</span>);
                error(errormsg)
            <span class="keyword">end</span>
            diagnostics.F = F;
            assignin(<span class="string">"base"</span>,<span class="string">"F"</span>,array2table(F,<span class="string">"VariableNames"</span>,VariableNames_F))

            <span class="comment">% Variable Borrower Data</span>
            idx_fd_BV = DB.BorrowerVariableDataTable.GimmeCLAmatrix(<span class="string">"file_date"</span>) == FileDate;
            BV = DB.BorrowerVariableDataTable.DataMat(idx_fd_BV,:);
            VariableNames = DB.BorrowerVariableDataTable.VariableNames;
            VariableNames_B = cellstr(strcat(<span class="string">"B_"</span>,VariableNames));
            <span class="keyword">if</span> size(BV,1)&lt;1
                errormsg = sprintf(<span class="string">'cannot find Borrower (variable) data associated with the file date.\n'</span>);
                error(errormsg)
            <span class="keyword">end</span>
            diagnostics.BV = BV;



            <span class="comment">% Link Facility Data based on Facility ID</span>
            idx_facid_L = strcmpi(DB.LoanDataTable.VariableNames,<span class="string">"Facility_ID"</span>);
            <span class="keyword">if</span> sum(idx_facid_L)~=1
                errmsg = sprintf(<span class="string">'cannot find Facility ID in Loan Data Table.\n'</span>);
                error(errmsg);
            <span class="keyword">end</span>
            idx_facid_F = strcmpi(DB.FacilitiesDataTable.VariableNames,<span class="string">"Facility_ID"</span>);
            <span class="keyword">if</span> sum(idx_facid_F)~=1
                errmsg = sprintf(<span class="string">'cannot find Facility ID in Facility Data Table.\n'</span>);
                error(errmsg);
            <span class="keyword">end</span>
            [ina_facID, locb_facID] = ismember(L(:,idx_facid_L),F(:,idx_facid_F));
            LF = [L(ina_facID,:),F(locb_facID(ina_facID),:)];
            VariableNames_LF = [VariableNames_L,VariableNames_F];

            <span class="comment">% Link Borrower Variable Data using Borrower ID</span>
            idx_borID_LF = strcmpi(VariableNames_LF,<span class="string">"L_borrower_ID"</span>);
            idx_borID_BV = strcmpi(DB.BorrowerVariableDataTable.VariableNames,<span class="string">"borrower_ID"</span>);
            [ina_borID, locb_borID] = ismember(LF(:,idx_borID_LF),BV(:,idx_borID_BV));
            LFBV = [LF(ina_borID,:),BV(locb_borID(ina_borID),:)];
            VariableNames_LFBV = [VariableNames_LF,VariableNames_B];
            Diagnostics.idx_bordID_LF = idx_borID_LF;
            Diagnostics.idx_bordID_BV = idx_borID_BV;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;



            <span class="comment">% STATIC DATA -------------------------------------------------</span>
            <span class="comment">% Note that, by definition, Static data doesn't vary by date,</span>
            <span class="comment">% so we don't need to select the data specific to the input</span>
            <span class="comment">% file date.  Otherwise, we keep the algorithm consistent with</span>
            <span class="comment">% the other CLAdataTables.</span>
            BS = DB.BorrowerStaticDataTable.DataMat;
            VariableNames = DB.BorrowerStaticDataTable.VariableNames;
            VariableNames_S = cellstr(strcat(<span class="string">"S_"</span>,VariableNames));

            <span class="comment">% Link static data using Borrower ID</span>
            bid_BS = BS(:,strcmpi(VariableNames_S,<span class="string">"S_borrower_ID"</span>));
            bid_LFBV = LFBV(:,strcmpi(VariableNames_LFBV,<span class="string">"L_borrower_ID"</span>));
            [ina_borID, locb_borID] = ismember(bid_LFBV,bid_BS);
            LFBVS = [LFBV(ina_borID,:),BS(locb_borID(ina_borID),:)];
            VariableNamesFinal = [VariableNames_LFBV,VariableNames_S];



            <span class="comment">% OUTPUT ------------------------------------------------------</span>
            Diagnostics.L = L;
            Diagnostics.LVN = VariableNames_L;
            Diagnostics.F = F;
            Diagnostics.FVN = VariableNames_F;
            Diagnostics.BV = BV;
            Diagnostics.BVVN = VariableNames_B;
            Diagnostics.LF = LF;
            Diagnostics.LFVN = VariableNames_LF;
            Diagnostics.BS = BS;
            Diagnostics.BSVN = VariableNames_S;
            Diagnostics.LFBV = LFBV;
            Diagnostics.LFBVVN = VariableNames_LFBV;
            Diagnostics.H = LFBVS;

            Diagnostics.VariableNamesFinal = VariableNamesFinal;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;

            MAT = LFBVS;
            VariableNames = VariableNamesFinal;

        <span class="keyword">end</span>

        <span class="keyword">function</span> [MAT,VariableNames] = GimmeCLAHistMat(DB,varargin)
            <span class="comment">%</span>
            <span class="comment">% GimmeCLAHistMat</span>
            <span class="comment">%   Returns the full historical</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% GET INPUTS --------------------------------------------------</span>
            <span class="comment">% Get full list of filedates (we need to get this before</span>
            <span class="comment">% dealing with optional inputs because it is the default list</span>
            <span class="comment">% of file dates for the FileDates optional input variable).</span>
            FileDateTab = DB.fileDatesTab;

            <span class="comment">% Parse optional inputs</span>
            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% FileDates</span>
            <span class="comment">% Add optional input for File Dates (list of dates included in</span>
            <span class="comment">% the historical matrix returned)</span>
            def = FileDateTab.FileDate;
            addParameter(p,<span class="string">'FileDates'</span>,def,@(x) isnumeric(x));

            <span class="comment">% Add optional input for File Date Index (logical index</span>
            <span class="comment">% selecting which file dates (based on the file date table) to</span>
            <span class="comment">% include in the historical matrix returned)</span>
            def = true(size(FileDateTab.FileDate));
            addParameter(p,<span class="string">'FileDateIndex'</span>,def,@(x) islogical(x));

            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});

            <span class="comment">% The user cannot input both an index and a list of dates, if</span>
            <span class="comment">% he does, we go with the list of dates.</span>
            <span class="keyword">if</span> any(strcmpi(varargin,<span class="string">"filedates"</span>))
                FileDateIndex = true(size(p.Results.FileDates));
            <span class="keyword">else</span>
                FileDateIndex = p.Results.FileDateIndex;
            <span class="keyword">end</span>

            <span class="comment">% For filedates we use the provided value.  If the user</span>
            <span class="comment">% provided a filedates input, the index is set to all true, so</span>
            <span class="comment">% all provided filedates are used.  If the user provided a</span>
            <span class="comment">% filedateindex value and no filedates value, we limit the</span>
            <span class="comment">% filedates used to those indicated by the index.</span>
            filedates = p.Results.FileDates(FileDateIndex);


            <span class="comment">% BUILD MATRIX ------------------------------------------------</span>
            <span class="comment">% Initialize</span>
            H = [];

            <span class="comment">% Loop through each file date and build the full historical</span>
            <span class="comment">% matrix</span>
            <span class="keyword">for</span> d = 1:length(filedates)

                fd = filedates(d);
                [M,VN,~] = GimmeCLAMat(DB,fd);
                H = [H;M];

            <span class="keyword">end</span>

            <span class="comment">% ORGANIZE OUTPUTS --------------------------------------------</span>
            MAT = H;
            VariableNames = VN;

        <span class="keyword">end</span>

        <span class="keyword">function</span> TAB = GimmeCLATable(DB,FileDate)
            <span class="comment">%</span>
            <span class="comment">% GimmeCLATable</span>
            <span class="comment">%   Returns full data table, for a specific File Date</span>
            <span class="comment">%   matching by FileDate, and joined by facility and</span>
            <span class="comment">%   borrower.</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>


            error(<span class="string">"GimmeCLATable method no longer available"</span>)
            <span class="comment">% Get the Matrix for the Specific File Date</span>
            <span class="comment">%[MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate);</span>

            <span class="comment">% Convert the Matrix to a Table</span>
            <span class="comment">%LFVS = array2table(MAT,'VariableNames',VariableNames);</span>

            <span class="comment">% SINGLE PRICING DECISION</span>
            <span class="comment">% -------------------------------------------------------------</span>
            <span class="comment">%LFVS.SPD_ID = SinglePriceDecision(LFVS, {'BankID','file_date','CustomerKey','SpreadBPS'});</span>
            <span class="comment">%TAB = LFVS;</span>
            <span class="comment">%TAB = movevars(TAB, "SPD_ID", "Before", "BankID");</span>





        <span class="keyword">end</span>

        <span class="keyword">function</span> [TAB,SPIDdups] = GimmeCLAHistTab(DB,varargin)
            <span class="comment">%</span>
            <span class="comment">% GimmeCLAHistTab</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% GET INPUTS --------------------------------------------------</span>
            <span class="comment">% Get full list of filedates (we need to get this before</span>
            <span class="comment">% dealing with optional inputs because it is the default list</span>
            <span class="comment">% of file dates for the FileDates optional input variable).</span>
            FileDateTab = DB.fileDatesTab;

            <span class="comment">% Parse optional inputs</span>
            <span class="comment">% Get any optional arguments and set properties accordingly</span>
            <span class="comment">% Set the input parser</span>
            p = inputParser;

            <span class="comment">% FileDates</span>
            <span class="comment">% Add optional input for File Dates (list of dates included in</span>
            <span class="comment">% the historical matrix returned)</span>
            def = FileDateTab.FileDate;
            addParameter(p,<span class="string">'FileDates'</span>,def,@(x) isnumeric(x));

            <span class="comment">% Add optional input for File Date Index (logical index</span>
            <span class="comment">% selecting which file dates (based on the file date table) to</span>
            <span class="comment">% include in the historical matrix returned)</span>
            def = true(size(FileDateTab.FileDate));
            addParameter(p,<span class="string">'FileDateIndex'</span>,def,@(x) islogical(x));

            <span class="comment">% Parse and set results</span>
            parse(p,varargin{:});

            <span class="comment">% The user cannot input both an index and a list of dates, if</span>
            <span class="comment">% he does, we go with the list of dates.</span>
            idx_have_filedates = any(cell2mat(<span class="keyword">...</span>
                cellfun(@(x) strcmpi(<span class="string">"filedates"</span>,x),<span class="keyword">...</span>
                varargin,<span class="string">'UniformOutput'</span>,false)));
            <span class="keyword">if</span> idx_have_filedates
                FileDateIndex = true(size(p.Results.FileDates));
            <span class="keyword">else</span>
                FileDateIndex = p.Results.FileDateIndex;
            <span class="keyword">end</span>

            <span class="comment">% For filedates we use the provided value.  If the user</span>
            <span class="comment">% provided a filedates input, the index is set to all true, so</span>
            <span class="comment">% all provided filedates are used.  If the user provided a</span>
            <span class="comment">% filedateindex value and no filedates value, we limit the</span>
            <span class="comment">% filedates used to those indicated by the index.</span>
            filedates = p.Results.FileDates(FileDateIndex);

            <span class="comment">% GET MATRIX --------------------------------------------------</span>
            [M,VariableNames] = GimmeCLAHistMat(DB,<span class="string">'FileDates'</span>,filedates);

            <span class="comment">% CONVERT TO TABLE --------------------------------------------</span>
            T = array2table(M,<span class="string">'VariableNames'</span>,VariableNames);

            <span class="comment">% SINGLE PRICING DECISION -------------------------------------</span>
            matchvars ={<span class="string">'L_Bank_ID'</span>,<span class="string">'L_file_date'</span>,<span class="string">'L_borrower_ID'</span>,<span class="string">'L_spread_bps'</span>};
            [T.PriceDecisionID,dups] =  DB.SinglePriceDecision(T,matchvars);
            T = movevars(T, <span class="string">"PriceDecisionID"</span>, <span class="string">"Before"</span>, 1);

            <span class="comment">% ORGANIZE OUTPUT ---------------------------------------------</span>
            SPIDdups = dups;
            TAB = T;

        <span class="keyword">end</span>

        <span class="keyword">function</span> [PriceDecisionID,dups] =  SinglePriceDecision(DB,TAB,matchvars)
            <span class="comment">%</span>
            <span class="comment">% SINGLE PRICING DECISION</span>
            <span class="comment">% If there are multiple loans made within the same period</span>
            <span class="comment">% between the same bank and the same borrower, we consider</span>
            <span class="comment">% that a "single pricing decision", those prices are grouped</span>
            <span class="comment">% together as one.</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% t is a smaller version of TAB, with just the matched</span>
            <span class="comment">% variables.  Observations (rows) that match for these</span>
            <span class="comment">% variables should be treated as a single observation.</span>
            <span class="comment">%matchvars ={'BankID','ProcessingDateKey','CustomerKey','SpreadBPS'};</span>
            t = TAB(:,matchvars);

            <span class="comment">% Find duplicate rows in t</span>
            <span class="comment">% use grpstats to group the table by the matchvars, rows with</span>
            <span class="comment">% more than one GroupCount will have duplicate observations.</span>
            g = grpstats(t,matchvars);
            idx_dups = g.GroupCount&gt;1;

            <span class="comment">% Create an id column (PriceDecisionID) unique for each pricing</span>
            <span class="comment">% decision</span>
            [~,PriceDecisionID] = ismember(t(:,matchvars),g(:,matchvars),<span class="string">'rows'</span>);

            <span class="comment">% Once we have identified the observations that match (the</span>
            <span class="comment">% single pricing decision observations), we pull those out and</span>
            <span class="comment">% store them in the singlepricedec table (can be returned for</span>
            <span class="comment">% reference).</span>
            [idx_singlepricedec,locb] = ismember(TAB(:,matchvars),g(idx_dups,matchvars));
            dups = TAB(idx_singlepricedec,:);
            dups.ID = locb(idx_singlepricedec);
            dups = movevars(dups, <span class="string">"ID"</span>, <span class="string">"Before"</span>, 1);


        <span class="keyword">end</span>

        <span class="keyword">function</span> FileDateTab = fileDatesTab(DB)
            <span class="comment">%</span>
            <span class="comment">% FileDateTab</span>
            <span class="comment">%</span>
            <span class="comment">% Returns a table with all of the available file dates in a</span>
            <span class="comment">% CLAdataBase as well as the date parts (year, month, day, and</span>
            <span class="comment">% full date).</span>
            <span class="comment">% -------------------------------------------------------------</span>


            FileDateTab = array2table(DB.AvailableFileDates, <span class="string">'VariableNames'</span>,{<span class="string">'FileDate'</span>});
            FileDateTab.FileDateYears = year(FileDateTab.FileDate);
            FileDateTab.FileDateMonths = month(FileDateTab.FileDate);
            FileDateTab.FileDateDays = day(FileDateTab.FileDate);
            FileDateTab.FileDates = datetime(FileDateTab.FileDateYears,FileDateTab.FileDateMonths,FileDateTab.FileDateDays);



        <span class="keyword">end</span>

        <span class="keyword">function</span> [POPGRID, OBS_FULL, diagnostics] = GimmeOBS(DB,GRID,filedate)
            <span class="comment">%</span>
            <span class="comment">% returns the OBStab (observation table) for the given file</span>
            <span class="comment">% date. the OBStab translates the observations into the defined</span>
            <span class="comment">% groups as per the grid.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% -------------------------------------------------------------</span>

            <span class="comment">% Get the full historical data set in the DB ------------------</span>
            H = DB.H;

            <span class="comment">% Initialize --------------------------------------------------</span>
            <span class="comment">% Initialize the Dimensions Cell Array and the Diagnostics structure</span>
            dimensions = struct;
            diagnostics = struct();

            <span class="comment">% Create the Spread Variable ----------------------------------</span>
            h0 = H;
            h0.SPR = h0.L_spread_bps;
            h0 = movevars(h0, <span class="string">"SPR"</span>, <span class="string">"Before"</span>, 1);


            <span class="comment">% Create the Lag Variable (Lag) -------------------------------</span>
            <span class="comment">% We create the lag by calcuating the difference between the selected</span>
            <span class="comment">% filedate and the file date in the historical observation data.  Positive</span>
            <span class="comment">% numbers represent historical dates and negative numbers would represent</span>
            <span class="comment">% future dates (so they match the lags in the GRID).</span>
            h0.Lag = calmonths(between(datetime(h0.L_file_date,<span class="string">'convertfrom'</span>,<span class="string">'datenum'</span>),filedate,<span class="string">'months'</span>));
            h0 = movevars(h0, <span class="string">"Lag"</span>, <span class="string">"Before"</span>, 2);
            assignin(<span class="string">"base"</span>,<span class="string">'h0'</span>,h0)

            <span class="comment">% Keep only data within the maximum lag period</span>
            idx_lagKeep = ismember(h0.Lag,GRID.Lag.Lag);
            diagnostics.idx_lagKeep = idx_lagKeep;

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.Lag.gridvar = <span class="string">'Lag'</span>;
            dimensions.Lag.distvar = <span class="string">'Lag'</span>;

            <span class="comment">% New Or Renewal (REMOVE UNWANTED RECORDS) --------------------</span>
            <span class="comment">% the GRID may include, new originations, renewals, or both.  Here we</span>
            <span class="comment">% remove any origination type that the user does not want to included in</span>
            <span class="comment">% the grid.</span>
            idx_includeOrigination = ismember(h0.L_Loan_Origination_Status,GRID.NewOrRenewal);
            diagnostics.idx_includeOrigination = idx_includeOrigination;
            h0.NewOrRenewal = h0.L_Loan_Origination_Status;
            h0 = movevars(h0, <span class="string">"NewOrRenewal"</span>, <span class="string">"Before"</span>, 3);

            <span class="comment">% NOTE: New or Renewal is not a dimension along which we measure distance,</span>
            <span class="comment">% it is a way we may or may not limit the data.</span>

            <span class="comment">% Index/Rate Type (REMOVE UNWANTED RECORDS) -------------------</span>
            <span class="comment">% the GRID will be limited to loans of a given index (i.e. LIBOR/SOFR,</span>
            <span class="comment">% PRIME, Fixed).  Since the Rate/Index is affected by two  different</span>
            <span class="comment">% variables in the data (Index and RateType), the grid stores a table with</span>
            <span class="comment">% both variables.</span>
            indexIDs = GRID.RateType.IndexIDs{GRID.RateType.USE};
            pricingStructureIDs = GRID.RateType.PricingStructureIDs(GRID.RateType.USE);
            idx_index2Include = and(ismember(h0.L_Index,indexIDs),ismember(h0.L_pricing_structure,pricingStructureIDs));
            diagnostics.idx_index2Include = idx_index2Include;
            h0.RateType = h0.L_Index;
            h0 = movevars(h0, <span class="string">"RateType"</span>, <span class="string">"Before"</span>, 1);

            <span class="comment">% NOTE: Index/Rate Type is not a dimension along which we measure distance,</span>
            <span class="comment">% it is a way we may or may not limit the data.</span>

            <span class="comment">% Facility Type -----------------------------------------------</span>
            <span class="comment">% the GRID may be limited to certain facility types as selected by the user</span>
            h0.FacilityType = h0.L_Loan_Type;
            h0 = movevars(h0, <span class="string">"FacilityType"</span>, <span class="string">"Before"</span>, 1);

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.FacilityType.gridvar = <span class="string">'FacilityType'</span>;
            dimensions.FacilityType.distvar = <span class="string">'FacilityType'</span>;

            <span class="comment">% Create the Loan Size Group ----------------------------------</span>
            <span class="comment">% This code block divides the portfolio into groups based on</span>
            <span class="comment">% CommitmentAmt at each break point.  If there are n break points,</span>
            <span class="comment">% there will be n+1 groups.</span>
            <span class="comment">% Loans with sizes outside of the range will not be removed,</span>
            <span class="comment">% but the loan size groups will be limited to those within the</span>
            <span class="comment">% range (only those groups will be shown in the grid).</span>
            LoanSizeBreakPoints = 1000000 .* GRID.LoanSize.Groups;
            h0.LoanSizeGroup = ones(size(h0,1),1);
            <span class="keyword">for</span> p = 1:length(LoanSizeBreakPoints)
                bp = LoanSizeBreakPoints(p);
                idx_greaterThanBreak = h0.F_Commitment_Amount &gt; bp;
                h0.LoanSizeGroup(idx_greaterThanBreak) = p+1;
            <span class="keyword">end</span>


            <span class="comment">% Move the variables</span>
            h0.LoanSize = h0.F_Commitment_Amount;
            h0 = movevars(h0, <span class="string">"LoanSizeGroup"</span>, <span class="string">"Before"</span>, 3);
            h0 = movevars(h0, <span class="string">"LoanSize"</span>, <span class="string">"Before"</span>, 3);

            <span class="comment">% check</span>
            diagnostics.chk_LoanSizeGroup = grpstats(h0(:,{<span class="string">'LoanSize'</span>,<span class="string">'F_Commitment_Amount'</span>}),<span class="string">"LoanSize"</span>,{<span class="string">'max'</span>,<span class="string">'min'</span>});

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.LoanSize.gridvar = <span class="string">'LoanSizeGroup'</span>;
            dimensions.LoanSize.distvar = <span class="string">'LoanSize'</span>;

            <span class="comment">% Identify NaN Loan Sizes</span>
            idx_BadLoanSize = isnan(h0.LoanSize);
            diagnostics.idx_BadLoanSize = idx_BadLoanSize;


            <span class="comment">% Create the Risk Category Group ------------------------------</span>
            <span class="comment">% This code block divides the portfolio into groups based on</span>
            <span class="comment">% Risk Rating (PD) at each break point.  If there are n break points,</span>
            <span class="comment">% there will be n+1 groups</span>
            RiskCatBreakPoints = GRID.RiskCategories.Groups;
            h0.RiskCategories = ones(size(h0,1),1);
            <span class="keyword">for</span> p = 1:length(RiskCatBreakPoints)
                bp = RiskCatBreakPoints(p);
                idx_greaterThanBreak = h0.B_Risk_Rating &gt; bp;
                h0.RiskCategories(idx_greaterThanBreak) = p+1;
            <span class="keyword">end</span>

            <span class="comment">% identify records with risk rating outside of the set range</span>
            idx_outOfRiskBounds = or(h0.B_Risk_Rating&lt;GRID.RiskCategories.Min,<span class="keyword">...</span>
                h0.B_Risk_Rating&gt;GRID.RiskCategories.Max);
            diagnostics.idx_outOfRiskBounds = idx_outOfRiskBounds;

            <span class="comment">% Move the variable</span>
            h0 = movevars(h0, <span class="string">"RiskCategories"</span>, <span class="string">"Before"</span>, 3);

            <span class="comment">% check</span>
            diagnostics.chk_RiskRatings = grpstats(h0(:,{<span class="string">'RiskCategories'</span>,<span class="string">'B_Risk_Rating'</span>}),<span class="string">"RiskCategories"</span>,{<span class="string">'max'</span>,<span class="string">'min'</span>});

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.RiskCategories.gridvar = <span class="string">'RiskCategories'</span>;
            dimensions.RiskCategories.distvar = <span class="string">'RiskCategories'</span>;

            <span class="comment">% Identify NaN RiskRatings</span>
            diagnostics.idx_BadRiskRating = isnan(h0.RiskCategories);

            <span class="comment">% Create Term Category Groups ---------------------------------</span>
            <span class="comment">% This code block divides the portfolio into groups based on</span>
            <span class="comment">% Term at each break point.  If there are n break points,</span>
            <span class="comment">% there will be n+1 groups</span>

            <span class="comment">% Start by calculating term from start date and maturity date of the loan</span>
            <span class="comment">%h0.TermMonths = calmonths(between(...</span>
            <span class="comment">%    datetime(h0.L_loan_effective_date,'convertfrom','datenum'),...</span>
            <span class="comment">%    datetime(h0.L_loan_maturity_date,'convertfrom','datenum'),...</span>
            <span class="comment">%    'months'));</span>
            h0.Term = log(h0.TermMonths);

            TermCatBreakPoints = GRID.TermCategories.Groups;
            h0.TermCategories = ones(size(h0,1),1);
            <span class="keyword">for</span> p = 1:length(TermCatBreakPoints)
                bp = TermCatBreakPoints(p);
                idx_greaterThanBreak = h0.TermMonths &gt; bp;
                h0.TermCategories(idx_greaterThanBreak) = p+1;
            <span class="keyword">end</span>

            <span class="comment">% Remove records with risk rating outside of the set range</span>
            diagnostics.idx_outOfRiskBounds = or(h0.TermMonths&lt;GRID.TermCategories.Min,<span class="keyword">...</span>
                h0.TermMonths&gt;GRID.TermCategories.Max);

            <span class="comment">% Move the variable</span>
            h0 = movevars(h0, <span class="string">"TermCategories"</span>, <span class="string">"Before"</span>, 4);
            h0 = movevars(h0,<span class="string">"TermMonths"</span>,<span class="string">"Before"</span>,4);

            <span class="comment">% check</span>
            diagnostics.chk_TermGroup = grpstats(h0(:,{<span class="string">'TermCategories'</span>,<span class="string">'TermMonths'</span>}),<span class="string">"TermCategories"</span>,{<span class="string">'max'</span>,<span class="string">'min'</span>});

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.TermCategories.gridvar = <span class="string">'TermCategories'</span>;
            dimensions.TermCategories.distvar = <span class="string">'Term'</span>;

            <span class="comment">% Identify NaN Terms Sizes</span>
            diagnostics.idx_BadTermCategories = isnan(h0.TermCategories);



            <span class="comment">% Collateral Group --------------------------------------------</span>
            <span class="comment">% Assign a collateral group to each loan in the observations</span>

            <span class="comment">% Initialize</span>
            h0.CollateralGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, <span class="string">"CollateralGroups"</span>, <span class="string">"Before"</span>, 5);

            <span class="comment">% Loop through each Collateral category and assign its Id to the</span>
            <span class="comment">% appropriate loan observations</span>
            gridids = GRID.CollateralGroups.SecGID;
            <span class="keyword">for</span> c = 1:length(gridids)

                <span class="keyword">try</span>

                    gridid = gridids(c);

                    <span class="comment">% Sometimes it seems that the collateral IDs are in a</span>
                    <span class="comment">% cell, if they are, we pull them out.</span>
                    CollateralIds = GRID.CollateralGroups.SecurityCategoryIDs{c};
                    <span class="keyword">if</span> iscell(CollateralIds)
                        fprintf(<span class="string">'unwrapping collateral ids...'</span>)
                        CollateralIds = CollateralIds{:,:};
                        fprintf(<span class="string">'out of cell.\n'</span>)
                    <span class="keyword">end</span>

                    <span class="comment">% If there is only one Collateral ID (scalar), we use</span>
                    <span class="comment">% == otherwise we use ismember</span>
                    <span class="keyword">if</span> isscalar(CollateralIds)
                        idx_inCurrentCollateralGroup = h0.L_Collateral_Type == CollateralIds;
                    <span class="keyword">else</span>
                        idx_inCurrentCollateralGroup = ismember(h0.L_Collateral_Type,CollateralIds);
                    <span class="keyword">end</span>
                    h0.CollateralGroups(idx_inCurrentCollateralGroup) = gridid;

                <span class="keyword">catch</span> ME
                    assignin(<span class="string">"base"</span>,<span class="string">'CollateralIds'</span>,CollateralIds)
                    assignin(<span class="string">"base"</span>,<span class="string">"h0"</span>,h0)
                    assignin(<span class="string">"base"</span>,<span class="string">"c"</span>,c)
                    rethrow(ME)
                <span class="keyword">end</span>


            <span class="keyword">end</span>

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.CollateralGroups.gridvar = <span class="string">'CollateralGroups'</span>;
            dimensions.CollateralGroups.distvar = <span class="string">'CollateralGroups'</span>;

            <span class="comment">% Identify NaN Collateral Groups</span>
            diagnostics.idx_BadCollateralGroup = isnan(h0.CollateralGroups);



            <span class="comment">% Industry Group ----------------------------------------------</span>
            <span class="comment">% Assign an industry group to each loan in the observations</span>

            <span class="comment">% Create 2-digit NAICS code</span>
            h0.NAICS2 = floor(h0.B_NAICS_code ./ 10000);
            h0 = movevars(h0, <span class="string">"NAICS2"</span>, <span class="string">"Before"</span>, <span class="string">"B_NAICS_code"</span>);

            <span class="comment">% Initialize</span>
            h0.IndustryGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, <span class="string">"IndustryGroups"</span>, <span class="string">"Before"</span>, 6);

            <span class="comment">% Loop through each Industry category and assign its Id to the</span>
            <span class="comment">% appropriate loan observations</span>
            indids = GRID.IndustryGroups.IndGrpID;
            <span class="keyword">for</span> c = 1:length(indids)

                indid = indids(c);
                IndustryIds = GRID.IndustryGroups.NAICS2s{c};
                idx_inCurrentIndustryGroup = ismember(h0.NAICS2,IndustryIds);
                h0.IndustryGroups(idx_inCurrentIndustryGroup) = indid;

            <span class="keyword">end</span>

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.IndustryGroups.gridvar = <span class="string">'IndustryGroups'</span>;
            dimensions.IndustryGroups.distvar = <span class="string">'IndustryGroups'</span>;

            <span class="comment">% Identify NaN Industry Groups</span>
            diagnostics.idx_BadIndustryGroup = isnan(h0.IndustryGroups);



            <span class="comment">% Geographies -------------------------------------------------</span>
            <span class="comment">% Assign a Geography ID to each loan. The Geography field is a</span>
            <span class="comment">% multi vector field.</span>

            <span class="comment">% First we get the location variables table (matches the</span>
            <span class="comment">% location name variables with the id variables), the</span>
            <span class="comment">% defGeographyTable function can return this table.</span>
            [~,~,~,LocVarsTab] = defGeographyTable(DB.TaxonomyTabs.LocationDatabase);

            <span class="comment">% Identify which variables (ID variables) are used in the GRID</span>
            <span class="comment">% to define geography</span>
            idx_locIDVars = ismember(GRID.Geographies.Properties.VariableNames, LocVarsTab.LocIDVar);
            GRIDlocIDVars = GRID.Geographies.Properties.VariableNames(idx_locIDVars);

            <span class="comment">% the observation data only has zip codes, so we need to match</span>
            <span class="comment">% each location by zipcode</span>
            [ina_zips, locb_zips] = ismember(h0.B_Zipcode,DB.TaxonomyTabs.LocationDatabase.zip_numeric);
            geographies = NaN(size(h0,1),length(GRIDlocIDVars));
            geographies(ina_zips,:) = DB.TaxonomyTabs.LocationDatabase{locb_zips(ina_zips),GRIDlocIDVars};

            <span class="comment">% Add geography variable to historical data table</span>
            h0.Geographies = geographies;
            h0 = movevars(h0, <span class="string">"Geographies"</span>, <span class="string">"Before"</span>, 7);

            <span class="comment">% Add variable to dimensions cell</span>
            dimensions.Geographies.gridvar = <span class="string">'Geographies'</span>;
            dimensions.Geographies.distvar = <span class="string">'Geographies'</span>;

            <span class="comment">% Identify NaN Geographies (cant find zips)</span>
            diagnostics.idx_BadGeographyGroup = isnan(any(h0.Geographies));

            <span class="comment">% Remove Excluded Loans ---------------------------------------</span>
            idx_KEEP = all([diagnostics.idx_lagKeep,<span class="keyword">...</span>
                diagnostics.idx_includeOrigination,<span class="keyword">...</span>
                diagnostics.idx_index2Include],2);
            h1 = h0(idx_KEEP,:);



            <span class="comment">% Combine by Pricing Decision ---------------------------------</span>
            idx_PriceDecisionZero = h1.PriceDecisionID == 0;
            h2 = h1(~idx_PriceDecisionZero,:);
            diagnostics.PriceDecisionZero = h0(idx_PriceDecisionZero,:);


            OBSvarNames = {<span class="string">'FacilityType'</span>,<span class="string">'Lag'</span>,<span class="string">'RiskCategories'</span>,<span class="string">'TermMonths'</span>,<span class="string">'TermCategories'</span>,<span class="string">'CollateralGroups'</span>,<span class="keyword">...</span>
                <span class="string">'IndustryGroups'</span>,<span class="string">'Geographies'</span>,<span class="string">'LoanSize'</span>,<span class="string">'LoanSizeGroup'</span>,<span class="string">'NewOrRenewal'</span>,<span class="string">'RateType'</span>,<span class="string">'SPR'</span>};
            OBS_FULL = h2(:,[{<span class="string">'PriceDecisionID'</span>},OBSvarNames]);


            <span class="comment">% Group by pricing decision, taking median of grouped variables. Then</span>
            <span class="comment">% remove the median_ prefix to the variable names.</span>
            G_med = grpstats(OBS_FULL,<span class="string">"PriceDecisionID"</span>,<span class="string">"median"</span>);
            G_med.Properties.VariableNames = strrep(G_med.Properties.VariableNames, <span class="string">"median_"</span>,<span class="string">""</span>);

            <span class="comment">% Group by pricing decision, taking mode of grouped variables. Then remove</span>
            <span class="comment">% the mode_ prefix to the variable names.</span>
            G_mod = grpstats(OBS_FULL,<span class="string">"PriceDecisionID"</span>,<span class="string">"mode"</span>);
            G_mod.Properties.VariableNames = strrep(G_mod.Properties.VariableNames, <span class="string">"mode_"</span>,<span class="string">""</span>);

            <span class="comment">% Construct the Observations Table using mode for categorical variables and</span>
            <span class="comment">% median for numeric variables</span>
            OBS = [G_med(:,{<span class="string">'PriceDecisionID'</span>,<span class="string">'GroupCount'</span>,<span class="string">'SPR'</span>}),<span class="keyword">...</span>
                G_mod(:,cellstr(char(GRID.Categoricals.Property(GRID.Categoricals.IsCat)))),<span class="keyword">...</span>
                G_med(:,cellstr(char(GRID.Categoricals.Property(~GRID.Categoricals.IsCat))))];
            OBS.OBS_ID = [1:size(OBS,1)]';
            OBS = movevars(OBS, <span class="string">"OBS_ID"</span>, <span class="string">"Before"</span>, 1);

            <span class="comment">% Remove any observations with NaN values</span>
            <span class="comment">%diagnostics.idx_OBSNaN = any(isnan(OBS{:,:}),2);</span>
            diagnostics.idx_OBSNaN = isnan(OBS.SPR);
            OBS = OBS(~diagnostics.idx_OBSNaN,:);

            <span class="comment">% Store information in a CLApopulatedGrid ---------------------</span>
            POPGRID = CLApopulatedGrid(GRID);
            POPGRID.OBS = OBS;
            POPGRID.dimensions = defDimensionsStruct(POPGRID.POPULATED_GRID);


        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024a</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
classdef CLAdataBase
    % CLAdataBase
    %   
    % Detailed explanation goes here
    %
    % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

    properties


        Description             % A string or char description of the 
                                % database


        LoanDataTable           % A CLAdataTable class ojbect holding the 
                                % Loan level data

        FacilitiesDataTable     % A CLAdataTable class object holding the 
                                % Facilities level data
                                % Fields must include:
                                %   - 

        BorrowerVariableDataTable % A CLAdataTable class object 
                                  % holding the Borrower level data
                                  % Fields must include:
                                  %   - 

        BorrowerStaticDataTable   % A CLAdataTable class object 
                                  % holding the Borrower level data
                                  % Fields must include:
                                  %   - 

        AvailableFileDates  % A list (vector) of unique file dates
                            % (dates on which the data were 
                            % assembled and delivered)

        Importer            % The importer (with much of the data removed 
                            % for space) but will hold the locations of the
                            % files that hold the raw imported data.


        TaxonomyTabs        % TaxonomyTabs is a data structure holding 
                            % MATLAB tables.  Each table must be named with 
                            % a variable held in VariableNames. All tables 
                            % in the structure must:
                            % (1) have only two variables, one with the 
                            % variable ID (named VariableNameID) and the 
                            % other with the translation of the variable ID
                            % to a categorical variable.
                            % (2) IDs must be numeric and be limited to the
                            % numbers held in the DataMat under the
                            % variable named in the table

         H                  % Historical table generated by gimmeCleanHist 
                            % holding the historical data. If generated by 
                            % gimmeCleanHist, also is cleaned and holds
                            % certain transformed fields.


    end

    methods
        function DB = CLAdataBase(LoanDataTable, FacilitiesDataTable, ...
                BorrowerVariableDataTable, BorrowerStaticDataTable)
            % CLAdataBase
            %   
            % Build an instance of a CLAdataBase class object
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % Set Data Table Properties
            DB.LoanDataTable = LoanDataTable;
            DB.FacilitiesDataTable = FacilitiesDataTable;
            DB.BorrowerVariableDataTable = BorrowerVariableDataTable;
            DB.BorrowerStaticDataTable = BorrowerStaticDataTable;

            % Set AvailableFileDates property (a full list of all
            % available File Dates). Note that static data does
            % not have processing date keys (because it is static), so we
            % do not need to pull out the dates from 
            % BorrowerStaticDataTable
            DB.AvailableFileDates = getFileDates(LoanDataTable,FacilitiesDataTable,BorrowerVariableDataTable);

            % Create TaxonomyTabs data structure (concatenation of each of
            % the individual TaxonomyTabs data structures from the database
            % components
            TT = struct();
            fieldnamesl = fieldnames(LoanDataTable.TaxonomyTabs);

            for l = 1:length(fieldnamesl)
                fn = fieldnamesl{l};
                TT.(char(fn)) = LoanDataTable.TaxonomyTabs.(char(fn));
            end

            fieldnamesf = fieldnames(FacilitiesDataTable.TaxonomyTabs);
            for f = 1:length(fieldnamesf)
                fn = fieldnamesf{f};
                TT.(char(fn)) = FacilitiesDataTable.TaxonomyTabs.(char(fn));
            end


            fieldnamesb = fieldnames(BorrowerVariableDataTable.TaxonomyTabs);
            for b = 1:length(fieldnamesb)
                fn = fieldnamesb{b};
                TT.(char(fn)) = BorrowerVariableDataTable.TaxonomyTabs.(char(fn));
            end

            fieldnamess = fieldnames(BorrowerStaticDataTable.TaxonomyTabs);
            for s = 1:length(fieldnamess)
                fn = fieldnamess{s};
                TT.(char(fn)) = BorrowerStaticDataTable.TaxonomyTabs.(char(fn));
            end

            DB.TaxonomyTabs = TT;

        end

        function DB = updateDB(DB,IMP)
            %
            %   UPDATE
            %
            %
            %
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-


            % VARIABLE DATA REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Variable data is updated on a month by month basis. So each
            % month comes in from either the input data or the existing
            % data (it cannot be mixed).

            % Set Import Files
            LOANDataTable = IMP.LOAN_updt;
            FACILITIESDataTable = IMP.FACILITIES_updt;
            BORROWERVariableDataTable = IMP.BORROWERV_updt;
            BORROWERStaticDataTable = IMP.BORROWERS_updt;
            Overwrite = IMP.Overwrite;

            % Get UpdtFileDates
            % Find New Dates for Dated data. If the user selected to
            % overwrite, the update file dates will be the same as the New
            % File Dates. Otherwise, the update file dates will only be the
            % file dates that do not currently have data in the database.
            NewFileDates = getFileDates(LOANDataTable,FACILITIESDataTable,BORROWERVariableDataTable);
            CurFileDates = DB.AvailableFileDates;

            if Overwrite
                UpdtFileDates = NewFileDates;
            else
                idx_newFDonly = ~ismember(NewFileDates,CurFileDates);
                UpdtFileDates = NewFileDates(idx_newFDonly);
            end

            % Update Facilities Data
            facilitiesDatatoAdd = FACILITIESDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            assignin("base","facilitiesDatatoAdd",facilitiesDatatoAdd)
            assignin("base","datamat",DB.FacilitiesDataTable.DataMat)
            DB.FacilitiesDataTable.DataMat = [DB.FacilitiesDataTable.DataMat;facilitiesDatatoAdd];
            

            % Update Loan Data
            loanDatatoAdd = LOANDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            DB.LoanDataTable.DataMat = [DB.LoanDataTable.DataMat; loanDatatoAdd];

            % Update Borrower Variable Data
            borrowervDatatoAdd = BORROWERVariableDataTable.GimmeCLAmatrix("ALL",'DateList',UpdtFileDates);
            DB.BorrowerVariableDataTable.DataMat = [DB.BorrowerVariableDataTable.DataMat; borrowervDatatoAdd];


            % AvailableFileDates PROPERTY REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Once we have changed the variable data (added file dates), we
            % need to update the AvailableFileDates property to reflect the
            % additional file dates
            DB.AvailableFileDates = getFileDates(DB.LoanDataTable,...
                DB.FacilitiesDataTable,DB.BorrowerVariableDataTable);


            % STATIC DATA REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % The borrower static data doesn't change from month to month,
            % so (depending on if we are overwriting) we only identify 
            % borrowers that do not exist in the current borrower static 
            % data. Everything is keyed off of borrower_ID

            % Get UpdtBIDs
            % Identify the borrower IDs that we will be updating
            newBIDs = BORROWERStaticDataTable.GimmeCLAmatrix("borrower_ID");
            curBIDs = DB.BorrowerStaticDataTable.GimmeCLAmatrix("borrower_ID");

            if Overwrite
                updBIDs = newBIDs;
            else
                idx_newBIDonly = ~ismember(newBIDs,curBIDs);
                updBIDs = newBIDs(idx_newBIDonly);
            end

            idx_BDtoAdd = ismember(BORROWERStaticDataTable.GimmeCLAmatrix("borrower_ID"),updBIDs);
            BDtoAdd = BORROWERStaticDataTable.DataMat(idx_BDtoAdd,:);
            DB.BorrowerStaticDataTable.DataMat = [DB.BorrowerStaticDataTable.DataMat;BDtoAdd];




        end

        function [DB,clean_diagnostics] = gimmeCleanHist(DB,YearTreasury,varargin)
            %
            %
            %
            %
            %


            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % YearTreasury


            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;

            % Calcualte Single Pricing IDs
            %[TAB,SPIDdups] = GimmeCLAHistTab(DB);



            % Get the untransformed, uncleaned historical data
            H = GimmeCLAHistTab(DB);
            
            %% TERM (IN MONTHS)
            % Remove facility data with NaN Effective Date, or NaN Maturity
            % Date, or Effective Date greater than Maturity Date
            
            % Calculate the Term
            H.TermMonths = split(between(...
                datetime(H.F_Facility_Effective_Date,'ConvertFrom','datenum'),...
                datetime(H.F_Facility_Maturity_Date,'ConvertFrom','datenum'),...
                'months'),'months');

            % Create Estimated Term Field
            H.Term_Estimated = H.TermMonths;
            H.Term_Estimated(isnan(H.Term_Estimated)) = mode(H.TermMonths(H.TermMonths>3));


            % Identify Negative or NaN term
            if strcmpi(termtype,'estimated')
                fprintf('cleanhist estimated.\n')
                idx_NegativeOrNaNTerm = or(isnan(H.Term_Estimated),H.Term_Estimated<1);
            else
                idx_NegativeOrNaNTerm = or(isnan(H.TermMonths),H.TermMonths<1);
            end

            clean_diagnostics.BadLoanData_BadTerm = H(idx_NegativeOrNaNTerm,:);
            clean_diagnostics.BadLoanData_BadTerm.Properties.Description = ...
                ['Facility data with errors in the term, either NaN effective date, ' ...
                'maturity date or negative term.'];
            
            % Clean Data
            % if term is less than zero, we set term to NaN (which will cause the
            % distance along the term dimension to be set to 1 (maximum)).
            H.TermMonths(idx_NegativeOrNaNTerm) = NaN;
                        
            % If term is greater than 30 years (360 months), remove the loan
            idx_TermMoreThan30years = H.TermMonths > 360;
            clean_diagnostics.TermMoreThan30Years = H(idx_TermMoreThan30years,:);
            H = H(~idx_TermMoreThan30years,:);
            
            
            %% LOAN SIZE
            % Loans with a commitment amount greater than 250MM will be excluded from
            % the data set
            idx_CommitOver250MM = H.F_Commitment_Amount > 250000000;
            clean_diagnostics.CommitOver250MM = H(idx_CommitOver250MM,:);
            H = H(~idx_CommitOver250MM,:);
            
            %% Pricing (NaN Pricing)
            % Remove fixed rate loans with NaN fixed rate, and remove floating rate
            % loans with NaN spreads
            idx_FixRateNaNRate = and(H.L_pricing_structure == 1, isnan(H.L_interest_rate_percent));
            clean_diagnostics.FixRateNanRate = H(idx_FixRateNaNRate,:);
            H = H(~idx_FixRateNaNRate,:);
            
            idx_FlRateNaNSpr = and(H.L_pricing_structure == 2, isnan(H.L_spread_bps));
            clean_diagnostics.FlRateNaNSpr = H(idx_FlRateNaNSpr,:);
            H = H(~idx_FlRateNaNSpr,:);
            
            %% Remove Obvioiusly Illegal Pricing
            % Spreads of more than 50% removed
            idx_illegal = or(and(H.L_pricing_structure == 2,H.L_spread_bps>5000),...
                and(H.L_pricing_structure == 1,H.L_interest_rate_percent>50));
            clean_diagnostics.ObviouslyIllegal = H(idx_illegal,:);
            H = H(~idx_illegal,:);
            
            %% Remove 0 Fixed Rates
            idx_zeroFixed = and(H.L_pricing_structure == 1, H.L_interest_rate_percent<0.00001);
            clean_diagnostics.ZeroFixed = H(idx_zeroFixed,:);
            H = H(~idx_zeroFixed,:);
            
            
            %% PRICING (off Market)
            % From Ryan: It looks like Fifth Third (bank 3), Business Banking (LOB 8), 
            % Term Loans (Loan Type 2) are the large majority of rates under 5% (an 
            % approximation of the 1 Year Treasury for 2023). Without this population, 
            % the number of low rates decreases drastically.
            %
            % Any loans with Bank_ID == 3, Line_of_Business == 8, AND Loan_Type ==2
            % will be considered excluded from the IQR range, but will be included in
            % the data set as long as it survives the other tests.
            %
            % All loans in a facility that includes the pricing fallilng outside of the
            % IQR will be removed.  This is for two reasons (1) practical: we can't use
            % the loanID since loan IDs are not unique across banks, and (2) it is
            % reasonable to belive that other pricing within a faciilty may be off
            % market to either "make up" for artificially low spreads, or if one is
            % erroneous, others may be too.
            
            % Add field to H table indicating whether the loan will be inclueed in the
            % IQR calculation
            idx_FifthThird = H.L_Bank_ID == 3;
            idx_LOB = H.L_Line_of_Business == 8;
            idx_Term = H.L_Loan_Type == 2;
            idx_notInIQR  = all([idx_FifthThird,idx_LOB,idx_Term],2);
            clean_diagnostics.excludedFromIQR = H(idx_notInIQR,:);
            H.notInIQR = idx_notInIQR;
            fprintf("%.0f loans marked outside of IQR calculation.\n",sum(H.notInIQR))
            
                        
            %% Idenfity Likely Outliers (using IQR)
            % Loop through each month and calculate the monthly IQR (excluding non-IQR
            % data), then identify all of the loans (using Loan Price ID) that will be
            % removed for being more than the threshold IQRs from the mean.
            fdsavailable = DB.AvailableFileDates;
            badSprSOFRFids = [];
            badSprPRIMEFids = [];
            badFixedFids = [];
            
            
            for m = 1:length(fdsavailable)
                mth = fdsavailable(m);
                M = H(H.L_file_date == mth,:);
            
                % Set up plot
                %figure('Position',[100 100 1070 500])
            
                %%% SPREADS to SOFR
                idx_SOFR = and(and(M.L_Index>=103,M.L_Index<=109),M.L_pricing_structure == 2); 
                MFL_SOFR = M(idx_SOFR,:);
                [r_spr,q_spr] = iqr(MFL_SOFR.L_spread_bps(~MFL_SOFR.notInIQR),"all");
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*1.5;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_SOFR.L_spread_bps>maxSPR;
                idx_SPRtooLow_m = MFL_SOFR.L_spread_bps<minSPR;
                badSprSOFRFids = [badSprSOFRFids;MFL_SOFR.L_Facility_ID(idx_SPRtooHigh_m);MFL_SOFR.L_Facility_ID(idx_SPRtooLow_m)];
                
                %subplot(1,3,1)
                %h = histogram(MFL_SOFR.L_spread_bps);
                %tit = sprintf('Spreads to SOFR\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %binwidth = h.BinWidth;
                %hold on
                %idx_excludeSPR = ismember(MFL_SOFR.L_Facility_ID,badSprSOFRFids);
                %histogram(MFL_SOFR.L_spread_bps(~idx_excludeSPR),'BinWidth',binwidth)
                %tit = sprintf('Spreads to SOFR\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %legend({'All Observations','Excluding Outliers'},...
                %    'Location','southoutside')
                %hold off
            
            
                %%% SPREADS to PRIME
                idx_PRIME = and(and(M.L_Index>=10,M.L_Index<=14),M.L_pricing_structure == 2); 
                MFL_PRIME = M(idx_PRIME,:);
                [r_spr,q_spr] = iqr(MFL_PRIME.L_spread_bps(~MFL_PRIME.notInIQR),"all");
                nIQRs = 1;
                maxSPR = q_spr(2)+r_spr*nIQRs;
                minSPR = q_spr(1)-r_spr*nIQRs;
                idx_SPRtooHigh_m = MFL_PRIME.L_spread_bps>maxSPR;
                idx_SPRtooLow_m = MFL_PRIME.L_spread_bps<minSPR;
                badSprPRIMEFids = [badSprPRIMEFids;MFL_PRIME.L_Facility_ID(idx_SPRtooHigh_m);MFL_PRIME.L_Facility_ID(idx_SPRtooLow_m)];
            
                %subplot(1,3,2)
                %h = histogram(MFL_PRIME.L_spread_bps);
                %binwidth = h.BinWidth;
                %tit = sprintf('Spread to PRIME\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %hold on
                %idx_excludeSPRPRIME = ismember(MFL_PRIME.L_Facility_ID,badSprPRIMEFids);
                %histogram(MFL_PRIME.L_spread_bps(~idx_excludeSPRPRIME),'BinWidth',binwidth);
                %legend({'All Observations','Excluding Outliers'},...
                %    'Location','southoutside')
                %hold off
            
            
                %%% FIXED RATES
                MFX = M(M.L_pricing_structure == 1,:);
                [r_fix,q_fix] = iqr(MFX.L_interest_rate_percent(~MFX.notInIQR),"all");
                nIQRs = 1;
                maxFIX = q_fix(2)+r_fix*nIQRs;
                minFIX = q_fix(1)-r_fix*nIQRs;
                idx_FIXtooHigh_m = MFX.L_interest_rate_percent>maxFIX;
                idx_FIXtooLow_m = MFX.L_interest_rate_percent<minFIX;
                badFixedFids = [badFixedFids;MFX.L_Facility_ID(idx_FIXtooHigh_m);MFX.L_Facility_ID(idx_FIXtooLow_m)];
            
                % Hard limit using treasuries
                Tmonth = mean(YearTreasury.DGS1(YearTreasury.MONTH == mth));
                TmonthMin = 0.75 .* Tmonth;
            
                %subplot(1,3,3)
                %h = histogram(MFX.L_interest_rate_percent);
                %binwidth = h.BinWidth;
                %tit = sprintf('Fixed Rate\n%s',...
                %    strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                %hold on
                
                idx_excludeFIX = ismember(MFX.L_Facility_ID,badFixedFids);

                %histogram(MFX.L_interest_rate_percent(~idx_excludeFIX),'BinWidth',binwidth)
                %tit = sprintf('Fixed Rate\n(IQR: %.4f, Max: %.2f, Min: %.2f)\n%s',...
                %    (q_fix(2) - q_fix(1)),maxFIX, minFIX,strcat(num2str(month(mth)),"-",num2str(year(mth))));
                %title(tit)
                % 
                %hold on
                %yl = ylim();
                %plot([TmonthMin,TmonthMin],[0,yl(2)])
                %legend({'All Observations','Excluding Outliers','.75 of US Treasury (1year)'},...
                %    'Location','southoutside')
                %hold off
            
            
                
            end
            
            idx_badSpreads = ismember(H.PriceDecisionID,badSprSOFRFids);
            clean_diagnostics.SPRtooHighOrtooLow = H(idx_badSpreads,:);
            H = H(~idx_badSpreads,:);
            
            idx_badFixed = ismember(H.PriceDecisionID,badFixedFids);
            clean_diagnostics.FIXtooHighortooLow = H(idx_badFixed,:);
            H = H(~idx_badFixed,:);

            %% Set DB.H Property
            DB.H = H;







        end
        
        function DB = swapToLIBOR(DB,SI,varargin)
            % SwapToLibor
            %
            % Swaps fixed rate loans to LIBOR (in Loans Table)
            % Stores unswapped rate as UnswappedSPR
            %
            %
            % 

            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;   


            % Check that the swap Importer has a Libor Table
            if isempty(SI.LIBOR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the swap Importer has a LIBOR Table
            if isempty(SI.LIBOR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the history has been generated
            if isempty(DB.H)
                msg = sprintf('missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n');
                error(msg)
            end

            % Check that history has been cleaned
            if ~ismember('notInIQR',DB.H.Properties.VariableNames)
                msg = sprintf('missing certain historical data fields. Please run gimmeCleanHist then swap.\n');
                error(msg)
            end


            % Set inputs
            SWAPS = SI.LIBOR;
            LOANS = DB.H;


            % Initialize Output Series
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);
          

            for l = 1:size(LOANS,1)
            
                % Get the Date of the swap. Start by finding the file date of the loan,
                % then, if that date has swap data, use that date, otherwise, find the
                % closest date.
                loanDate = LOANS.L_file_date(l);
                if ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                else
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                end
            
                % Get the row of the swap (associated with the date)
                idx_swaprow = SWAPS.SWAPDATE == swapdate;
            
                if sum(idx_swaprow) == 1
                
                    % Get the column of the swap table (associated with the swap tenor   
                    % Use the term of the loan to identify Which Swap Series we are Looking 
                    % for
                    if strcmpi(termtype,'estimated')
                        swapvarn = strcat("LIBORSWAP_",num2str(LOANS.Term_Estimated(l)));
                    else
                        swapvarn = strcat("LIBORSWAP_",num2str(LOANS.TermMonths(l)));
                    end
            
                    % If there the swap variable name is valid (term of the loan
                    % reflects a swap value), return the swap rate
                    if ismember(swapvarn,SWAPS.Properties.VariableNames)
                        % Return the swap rate
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    else
                        % bad swap tenor error
                        swapRateERR(l) = swapRateERR(l)+10;
                    end
            
                else
                    % bad swap date error
                    swapRateERR(l) = swapRateERR(l)+1;
                end
            end
            
            % Add Swap Rate to Table
            LOANS.SwapRate_LIBOR =  swapRate;

            % Add Error Series to TAble
            LOANS.SwapErrorKey = swapRateERR;
            
            % Store Unswapped spreads
            LOANS.UnswappedSPR = LOANS.L_spread_bps;
            
            % Store Swapped Spread
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_LIBOR(idx_fixed);
            DB.H = LOANS;

        end

        function DB = swapToSOFR(DB,SI,varargin)
            % SwapToSOFR
            %
            % Swaps fixed rate loans to SOFR (in Loans Table)
            % Stores unswapped rate as UnswappedSPR
            %
            %
            % 


            % Get optional Parameters
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;

            % Term
            def = 'actual';
            defmsg = sprintf(['Problem with the TermType input. the ' ...
                'TermType input must be a string or char and must be equal ' ...
                'either to "actual" or "estimated"']);
            addParameter(p,'TermType',def,...
                @(x)...
                assert(and(or(isstring(x),ischar(x)),...
                or(strcmpi(x,'actual'),strcmpi(x,'estimated'))),...
                defmsg)...
                );

            % Parse and set results
            parse(p,varargin{:});
            termtype = p.Results.TermType;      

            % Check that the swap Importer has a SOFR Table
            if isempty(SI.SOFR)
                msg = sprintf("missing swap data.\n");
                error(msg)
            end

            % Check that the history has been generated
            if isempty(DB.H)
                msg = sprintf('missing historical data. Please generate historical data (gimmeCleanHist) then swap.\n');
                error(msg)
            end

            % Check that history has been cleaned
            if ~ismember('notInIQR',DB.H.Properties.VariableNames)
                msg = sprintf('missing certain historical data fields. Please run gimmeCleanHist then swap.\n');
                error(msg)
            end



            % Set inputs
            SWAPS = SI.SOFR;
            LOANS = DB.H;


            % Initialize Output Series
            swapRate = NaN(size(LOANS,1),1);
            swapRateERR = zeros(size(LOANS,1),1);
            
            
            
            for l = 1:size(LOANS,1)
            
                % Get the Date of the swap. Start by finding the file date of the loan,
                % then, if that date has swap data, use that date, otherwise, find the
                % closest date.
                loanDate = LOANS.L_file_date(l);
                if ismember(loanDate,SWAPS.SWAPDATE)
                    swapdate = loanDate;
                else
                    idx_nearestdate = abs(loanDate - SWAPS.SWAPDATE) == min(abs(loanDate - SWAPS.SWAPDATE));
                    swapdate = SWAPS.SWAPDATE(idx_nearestdate);
                end
            
                % Get the row of the swap (associated with the date)
                idx_swaprow = SWAPS.SWAPDATE == swapdate;
            
                if sum(idx_swaprow) == 1
                
                    % Get the column of the swap table (associated with the swap tenor   
                    % Use the term of the loan to identify Which Swap Series we are Looking 
                    % for
                    if strcmpi(termtype,'estimated')
                        swapvarn = strcat("SOFRSWAP_",num2str(LOANS.Term_Estimated(l)));
                    else
                        swapvarn = strcat("SOFRSWAP_",num2str(LOANS.TermMonths(l)));
                    end
            
                    % If there the swap variable name is valid (term of the loan
                    % reflects a swap value), return the swap rate
                    if ismember(swapvarn,SWAPS.Properties.VariableNames)
                        % Return the swap rate
                        swapRate(l) = SWAPS{idx_swaprow,swapvarn};
                    else
                        % bad swap tenor error
                        swapRateERR(l) = swapRateERR(l)+10;
                    end
            
                else
                    % bad swap date error
                    swapRateERR(l) = swapRateERR(l)+1;
                end
            end


            % Add Swap Rate to Table
            LOANS.SwapRate_SOFR =  swapRate;

            % Add Error Series to TAble
            LOANS.SwapErrorKey = swapRateERR;
            
            % Store Unswapped spreads
            LOANS.UnswappedSPR = LOANS.L_spread_bps;
            
            % Store Swapped Spread
            idx_fixed = LOANS.L_pricing_structure == 1;
            LOANS.spread_bps(idx_fixed) = 100 .* LOANS.L_interest_rate_percent(idx_fixed) - LOANS.SwapRate_SOFR(idx_fixed);
            DB.H = LOANS;


        end

        function [MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate)
            
            % GimmeCLAMat
            %
            % Returns matrix data from the CLA Database
            % Returns full matrix for a specific filedate
            % FileDate must be in datenumber format
            % 
            % This funciton is the basis for building the table returned in
            % GimmeCLATable.
            %
            % This function is the basis for building the historical matrix
            % and table returned in GimmeCLAHist
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            diagnostics = struct();

            % Check that File Date is available
            if ~ismember(FileDate,DB.AvailableFileDates)
                msg = sprintf('File date %.0f, not found in list of available dates.\n',FileDate);
                error(msg)
            end
            if numel(FileDate)>1
                msg = sprintf('FileDate must be a single date, not a vector or a range.\n');
                error(msg);
            end

            % VARIABLE DATA REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Get all the Variable Data (Loans, Facility,and Borrower),
            % associated with the specific filedate
            
            % Start with the loan data, set the 'L' table to hold all loan 
            % data from the specific file date.
            idx_fd_L = DB.LoanDataTable.GimmeCLAmatrix("file_date") == FileDate;
            L = DB.LoanDataTable.DataMat(idx_fd_L,:);
            VariableNames = DB.LoanDataTable.VariableNames;
            VariableNames_L = cellstr(strcat("L_",VariableNames));
            if size(L,1)<1
                errormsg = sprintf('cannot find Loan data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.L = L;
            assignin("base","L",array2table(L,"VariableNames",VariableNames_L))
            

            % Set the F table to hold all of the Facilities data from the
            % specific file date.
            idx_fd_F = DB.FacilitiesDataTable.GimmeCLAmatrix("file_date") == FileDate;
            F = DB.FacilitiesDataTable.DataMat(idx_fd_F,:);
            VariableNames = DB.FacilitiesDataTable.VariableNames;
            VariableNames_F = cellstr(strcat("F_",VariableNames));
            if size(F,1)<1
                errormsg = sprintf('cannot find Facility data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.F = F;
            assignin("base","F",array2table(F,"VariableNames",VariableNames_F))

            % Variable Borrower Data
            idx_fd_BV = DB.BorrowerVariableDataTable.GimmeCLAmatrix("file_date") == FileDate;
            BV = DB.BorrowerVariableDataTable.DataMat(idx_fd_BV,:);
            VariableNames = DB.BorrowerVariableDataTable.VariableNames;
            VariableNames_B = cellstr(strcat("B_",VariableNames));
            if size(BV,1)<1
                errormsg = sprintf('cannot find Borrower (variable) data associated with the file date.\n');
                error(errormsg)
            end
            diagnostics.BV = BV;



            % Link Facility Data based on Facility ID
            idx_facid_L = strcmpi(DB.LoanDataTable.VariableNames,"Facility_ID");
            if sum(idx_facid_L)~=1
                errmsg = sprintf('cannot find Facility ID in Loan Data Table.\n');
                error(errmsg);
            end
            idx_facid_F = strcmpi(DB.FacilitiesDataTable.VariableNames,"Facility_ID");
            if sum(idx_facid_F)~=1
                errmsg = sprintf('cannot find Facility ID in Facility Data Table.\n');
                error(errmsg);
            end            
            [ina_facID, locb_facID] = ismember(L(:,idx_facid_L),F(:,idx_facid_F));
            LF = [L(ina_facID,:),F(locb_facID(ina_facID),:)];
            VariableNames_LF = [VariableNames_L,VariableNames_F];

            % Link Borrower Variable Data using Borrower ID
            idx_borID_LF = strcmpi(VariableNames_LF,"L_borrower_ID");
            idx_borID_BV = strcmpi(DB.BorrowerVariableDataTable.VariableNames,"borrower_ID");
            [ina_borID, locb_borID] = ismember(LF(:,idx_borID_LF),BV(:,idx_borID_BV));
            LFBV = [LF(ina_borID,:),BV(locb_borID(ina_borID),:)];
            VariableNames_LFBV = [VariableNames_LF,VariableNames_B];
            Diagnostics.idx_bordID_LF = idx_borID_LF;
            Diagnostics.idx_bordID_BV = idx_borID_BV;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;



            % STATIC DATA REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Note that, by definition, Static data doesn't vary by date,
            % so we don't need to select the data specific to the input
            % file date.  Otherwise, we keep the algorithm consistent with
            % the other CLAdataTables.
            BS = DB.BorrowerStaticDataTable.DataMat;
            VariableNames = DB.BorrowerStaticDataTable.VariableNames;
            VariableNames_S = cellstr(strcat("S_",VariableNames));

            % Link static data using Borrower ID
            bid_BS = BS(:,strcmpi(VariableNames_S,"S_borrower_ID"));
            bid_LFBV = LFBV(:,strcmpi(VariableNames_LFBV,"L_borrower_ID"));
            [ina_borID, locb_borID] = ismember(bid_LFBV,bid_BS);
            LFBVS = [LFBV(ina_borID,:),BS(locb_borID(ina_borID),:)];
            VariableNamesFinal = [VariableNames_LFBV,VariableNames_S];



            % OUTPUT REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            Diagnostics.L = L;
            Diagnostics.LVN = VariableNames_L;
            Diagnostics.F = F;
            Diagnostics.FVN = VariableNames_F;
            Diagnostics.BV = BV;
            Diagnostics.BVVN = VariableNames_B;
            Diagnostics.LF = LF;
            Diagnostics.LFVN = VariableNames_LF;
            Diagnostics.BS = BS;
            Diagnostics.BSVN = VariableNames_S;
            Diagnostics.LFBV = LFBV;
            Diagnostics.LFBVVN = VariableNames_LFBV;
            Diagnostics.H = LFBVS;

            Diagnostics.VariableNamesFinal = VariableNamesFinal;
            Diagnostics.ina_borID = ina_borID;
            Diagnostics.locb_borID = locb_borID;
            
            MAT = LFBVS;
            VariableNames = VariableNamesFinal;

        end

        function [MAT,VariableNames] = GimmeCLAHistMat(DB,varargin)
            %
            % GimmeCLAHistMat
            %   Returns the full historical
            %
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % GET INPUTS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Get full list of filedates (we need to get this before
            % dealing with optional inputs because it is the default list
            % of file dates for the FileDates optional input variable).
            FileDateTab = DB.fileDatesTab;

            % Parse optional inputs
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;            
            
            % FileDates
            % Add optional input for File Dates (list of dates included in
            % the historical matrix returned)
            def = FileDateTab.FileDate;
            addParameter(p,'FileDates',def,@(x) isnumeric(x));

            % Add optional input for File Date Index (logical index
            % selecting which file dates (based on the file date table) to
            % include in the historical matrix returned)
            def = true(size(FileDateTab.FileDate));
            addParameter(p,'FileDateIndex',def,@(x) islogical(x));            

            % Parse and set results
            parse(p,varargin{:});

            % The user cannot input both an index and a list of dates, if
            % he does, we go with the list of dates.
            if any(strcmpi(varargin,"filedates"))
                FileDateIndex = true(size(p.Results.FileDates));
            else
                FileDateIndex = p.Results.FileDateIndex;
            end

            % For filedates we use the provided value.  If the user 
            % provided a filedates input, the index is set to all true, so 
            % all provided filedates are used.  If the user provided a
            % filedateindex value and no filedates value, we limit the
            % filedates used to those indicated by the index.
            filedates = p.Results.FileDates(FileDateIndex);


            % BUILD MATRIX REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Initialize
            H = [];

            % Loop through each file date and build the full historical
            % matrix
            for d = 1:length(filedates)

                fd = filedates(d);
                [M,VN,~] = GimmeCLAMat(DB,fd);
                H = [H;M];

            end

            % ORGANIZE OUTPUTS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            MAT = H;
            VariableNames = VN;
        
        end

        function TAB = GimmeCLATable(DB,FileDate)
            % 
            % GimmeCLATable
            %   Returns full data table, for a specific File Date 
            %   matching by FileDate, and joined by facility and 
            %   borrower.
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            

            error("GimmeCLATable method no longer available")
            % Get the Matrix for the Specific File Date
            %[MAT,VariableNames,Diagnostics] = GimmeCLAMat(DB,FileDate);

            % Convert the Matrix to a Table
            %LFVS = array2table(MAT,'VariableNames',VariableNames);

            % SINGLE PRICING DECISION
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            %LFVS.SPD_ID = SinglePriceDecision(LFVS, {'BankID','file_date','CustomerKey','SpreadBPS'});
            %TAB = LFVS;
            %TAB = movevars(TAB, "SPD_ID", "Before", "BankID");
            

 


        end

        function [TAB,SPIDdups] = GimmeCLAHistTab(DB,varargin)
            % 
            % GimmeCLAHistTab
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % GET INPUTS REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Get full list of filedates (we need to get this before
            % dealing with optional inputs because it is the default list
            % of file dates for the FileDates optional input variable).
            FileDateTab = DB.fileDatesTab;

            % Parse optional inputs
            % Get any optional arguments and set properties accordingly
            % Set the input parser
            p = inputParser;            
            
            % FileDates
            % Add optional input for File Dates (list of dates included in
            % the historical matrix returned)
            def = FileDateTab.FileDate;
            addParameter(p,'FileDates',def,@(x) isnumeric(x));

            % Add optional input for File Date Index (logical index
            % selecting which file dates (based on the file date table) to
            % include in the historical matrix returned)
            def = true(size(FileDateTab.FileDate));
            addParameter(p,'FileDateIndex',def,@(x) islogical(x));            

            % Parse and set results
            parse(p,varargin{:});

            % The user cannot input both an index and a list of dates, if
            % he does, we go with the list of dates.
            idx_have_filedates = any(cell2mat(...
                cellfun(@(x) strcmpi("filedates",x),...
                varargin,'UniformOutput',false)));
            if idx_have_filedates
                FileDateIndex = true(size(p.Results.FileDates));
            else
                FileDateIndex = p.Results.FileDateIndex;
            end

            % For filedates we use the provided value.  If the user 
            % provided a filedates input, the index is set to all true, so 
            % all provided filedates are used.  If the user provided a
            % filedateindex value and no filedates value, we limit the
            % filedates used to those indicated by the index.
            filedates = p.Results.FileDates(FileDateIndex);

            % GET MATRIX REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            [M,VariableNames] = GimmeCLAHistMat(DB,'FileDates',filedates);

            % CONVERT TO TABLE REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            T = array2table(M,'VariableNames',VariableNames);

            % SINGLE PRICING DECISION REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            matchvars ={'L_Bank_ID','L_file_date','L_borrower_ID','L_spread_bps'};
            [T.PriceDecisionID,dups] =  DB.SinglePriceDecision(T,matchvars);
            T = movevars(T, "PriceDecisionID", "Before", 1);

            % ORGANIZE OUTPUT REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            SPIDdups = dups;
            TAB = T;

        end

        function [PriceDecisionID,dups] =  SinglePriceDecision(DB,TAB,matchvars)
            % 
            % SINGLE PRICING DECISION
            % If there are multiple loans made within the same period
            % between the same bank and the same borrower, we consider
            % that a "single pricing decision", those prices are grouped
            % together as one.
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            
            % t is a smaller version of TAB, with just the matched
            % variables.  Observations (rows) that match for these
            % variables should be treated as a single observation.
            %matchvars ={'BankID','ProcessingDateKey','CustomerKey','SpreadBPS'}; 
            t = TAB(:,matchvars);
            
            % Find duplicate rows in t
            % use grpstats to group the table by the matchvars, rows with
            % more than one GroupCount will have duplicate observations.
            g = grpstats(t,matchvars);
            idx_dups = g.GroupCount>1;
            
            % Create an id column (PriceDecisionID) unique for each pricing
            % decision
            [~,PriceDecisionID] = ismember(t(:,matchvars),g(:,matchvars),'rows');
            
            % Once we have identified the observations that match (the
            % single pricing decision observations), we pull those out and
            % store them in the singlepricedec table (can be returned for
            % reference).
            [idx_singlepricedec,locb] = ismember(TAB(:,matchvars),g(idx_dups,matchvars));
            dups = TAB(idx_singlepricedec,:);
            dups.ID = locb(idx_singlepricedec);
            dups = movevars(dups, "ID", "Before", 1);


        end

        function FileDateTab = fileDatesTab(DB)
            %
            % FileDateTab
            %
            % Returns a table with all of the available file dates in a 
            % CLAdataBase as well as the date parts (year, month, day, and
            % full date).
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            
            FileDateTab = array2table(DB.AvailableFileDates, 'VariableNames',{'FileDate'});
            FileDateTab.FileDateYears = year(FileDateTab.FileDate);
            FileDateTab.FileDateMonths = month(FileDateTab.FileDate);
            FileDateTab.FileDateDays = day(FileDateTab.FileDate);
            FileDateTab.FileDates = datetime(FileDateTab.FileDateYears,FileDateTab.FileDateMonths,FileDateTab.FileDateDays);



        end

        function [POPGRID, OBS_FULL, diagnostics] = GimmeOBS(DB,GRID,filedate)
            %
            % returns the OBStab (observation table) for the given file
            % date. the OBStab translates the observations into the defined
            % groups as per the grid.
            %
            %
            %
            %
            %
            % REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-

            % Get the full historical data set in the DB REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            H = DB.H;
            
            % Initialize REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Initialize the Dimensions Cell Array and the Diagnostics structure
            dimensions = struct;
            diagnostics = struct();

            % Create the Spread Variable REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            h0 = H;
            h0.SPR = h0.L_spread_bps;
            h0 = movevars(h0, "SPR", "Before", 1);


            % Create the Lag Variable (Lag) REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % We create the lag by calcuating the difference between the selected
            % filedate and the file date in the historical observation data.  Positive
            % numbers represent historical dates and negative numbers would represent
            % future dates (so they match the lags in the GRID).
            h0.Lag = calmonths(between(datetime(h0.L_file_date,'convertfrom','datenum'),filedate,'months'));
            h0 = movevars(h0, "Lag", "Before", 2);
            assignin("base",'h0',h0)
            
            % Keep only data within the maximum lag period
            idx_lagKeep = ismember(h0.Lag,GRID.Lag.Lag);
            diagnostics.idx_lagKeep = idx_lagKeep;
            
            % Add variable to dimensions cell
            dimensions.Lag.gridvar = 'Lag';
            dimensions.Lag.distvar = 'Lag';
            
            % New Or Renewal (REMOVE UNWANTED RECORDS) REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % the GRID may include, new originations, renewals, or both.  Here we
            % remove any origination type that the user does not want to included in
            % the grid.
            idx_includeOrigination = ismember(h0.L_Loan_Origination_Status,GRID.NewOrRenewal);
            diagnostics.idx_includeOrigination = idx_includeOrigination;
            h0.NewOrRenewal = h0.L_Loan_Origination_Status;
            h0 = movevars(h0, "NewOrRenewal", "Before", 3);
            
            % NOTE: New or Renewal is not a dimension along which we measure distance,
            % it is a way we may or may not limit the data.

            % Index/Rate Type (REMOVE UNWANTED RECORDS) REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % the GRID will be limited to loans of a given index (i.e. LIBOR/SOFR,
            % PRIME, Fixed).  Since the Rate/Index is affected by two  different
            % variables in the data (Index and RateType), the grid stores a table with
            % both variables.
            indexIDs = GRID.RateType.IndexIDs{GRID.RateType.USE};
            pricingStructureIDs = GRID.RateType.PricingStructureIDs(GRID.RateType.USE);
            idx_index2Include = and(ismember(h0.L_Index,indexIDs),ismember(h0.L_pricing_structure,pricingStructureIDs));
            diagnostics.idx_index2Include = idx_index2Include;
            h0.RateType = h0.L_Index;
            h0 = movevars(h0, "RateType", "Before", 1);
            
            % NOTE: Index/Rate Type is not a dimension along which we measure distance,
            % it is a way we may or may not limit the data.

            % Facility Type REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % the GRID may be limited to certain facility types as selected by the user
            h0.FacilityType = h0.L_Loan_Type;
            h0 = movevars(h0, "FacilityType", "Before", 1);

            % Add variable to dimensions cell
            dimensions.FacilityType.gridvar = 'FacilityType';
            dimensions.FacilityType.distvar = 'FacilityType';

            % Create the Loan Size Group REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % This code block divides the portfolio into groups based on
            % CommitmentAmt at each break point.  If there are n break points,
            % there will be n+1 groups.
            % Loans with sizes outside of the range will not be removed,
            % but the loan size groups will be limited to those within the
            % range (only those groups will be shown in the grid).
            LoanSizeBreakPoints = 1000000 .* GRID.LoanSize.Groups;
            h0.LoanSizeGroup = ones(size(h0,1),1);
            for p = 1:length(LoanSizeBreakPoints)
                bp = LoanSizeBreakPoints(p);
                idx_greaterThanBreak = h0.F_Commitment_Amount > bp;
                h0.LoanSizeGroup(idx_greaterThanBreak) = p+1;
            end
            
            
            % Move the variables
            h0.LoanSize = h0.F_Commitment_Amount;
            h0 = movevars(h0, "LoanSizeGroup", "Before", 3);
            h0 = movevars(h0, "LoanSize", "Before", 3);            
            
            % check
            diagnostics.chk_LoanSizeGroup = grpstats(h0(:,{'LoanSize','F_Commitment_Amount'}),"LoanSize",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.LoanSize.gridvar = 'LoanSizeGroup';
            dimensions.LoanSize.distvar = 'LoanSize';            
            
            % Identify NaN Loan Sizes
            idx_BadLoanSize = isnan(h0.LoanSize);
            diagnostics.idx_BadLoanSize = idx_BadLoanSize;


            % Create the Risk Category Group REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % This code block divides the portfolio into groups based on
            % Risk Rating (PD) at each break point.  If there are n break points,
            % there will be n+1 groups
            RiskCatBreakPoints = GRID.RiskCategories.Groups;
            h0.RiskCategories = ones(size(h0,1),1);
            for p = 1:length(RiskCatBreakPoints)
                bp = RiskCatBreakPoints(p);
                idx_greaterThanBreak = h0.B_Risk_Rating > bp;
                h0.RiskCategories(idx_greaterThanBreak) = p+1;
            end
            
            % identify records with risk rating outside of the set range
            idx_outOfRiskBounds = or(h0.B_Risk_Rating<GRID.RiskCategories.Min,...
                h0.B_Risk_Rating>GRID.RiskCategories.Max);
            diagnostics.idx_outOfRiskBounds = idx_outOfRiskBounds;
            
            % Move the variable
            h0 = movevars(h0, "RiskCategories", "Before", 3);
            
            % check
            diagnostics.chk_RiskRatings = grpstats(h0(:,{'RiskCategories','B_Risk_Rating'}),"RiskCategories",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.RiskCategories.gridvar = 'RiskCategories';
            dimensions.RiskCategories.distvar = 'RiskCategories';                
            
            % Identify NaN RiskRatings
            diagnostics.idx_BadRiskRating = isnan(h0.RiskCategories);

            % Create Term Category Groups REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % This code block divides the portfolio into groups based on
            % Term at each break point.  If there are n break points,
            % there will be n+1 groups
            
            % Start by calculating term from start date and maturity date of the loan
            %h0.TermMonths = calmonths(between(...
            %    datetime(h0.L_loan_effective_date,'convertfrom','datenum'),...
            %    datetime(h0.L_loan_maturity_date,'convertfrom','datenum'),...
            %    'months'));
            h0.Term = log(h0.TermMonths);
            
            TermCatBreakPoints = GRID.TermCategories.Groups;
            h0.TermCategories = ones(size(h0,1),1);
            for p = 1:length(TermCatBreakPoints)
                bp = TermCatBreakPoints(p);
                idx_greaterThanBreak = h0.TermMonths > bp;
                h0.TermCategories(idx_greaterThanBreak) = p+1;
            end
            
            % Remove records with risk rating outside of the set range
            diagnostics.idx_outOfRiskBounds = or(h0.TermMonths<GRID.TermCategories.Min,...
                h0.TermMonths>GRID.TermCategories.Max);
            
            % Move the variable
            h0 = movevars(h0, "TermCategories", "Before", 4);
            h0 = movevars(h0,"TermMonths","Before",4);
            
            % check
            diagnostics.chk_TermGroup = grpstats(h0(:,{'TermCategories','TermMonths'}),"TermCategories",{'max','min'});
            
            % Add variable to dimensions cell
            dimensions.TermCategories.gridvar = 'TermCategories';
            dimensions.TermCategories.distvar = 'Term';                
            
            % Identify NaN Terms Sizes
            diagnostics.idx_BadTermCategories = isnan(h0.TermCategories);



            % Collateral Group REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Assign a collateral group to each loan in the observations
            
            % Initialize
            h0.CollateralGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, "CollateralGroups", "Before", 5);
            
            % Loop through each Collateral category and assign its Id to the
            % appropriate loan observations
            gridids = GRID.CollateralGroups.SecGID;
            for c = 1:length(gridids)

                try
                
                    gridid = gridids(c);

                    % Sometimes it seems that the collateral IDs are in a
                    % cell, if they are, we pull them out.
                    CollateralIds = GRID.CollateralGroups.SecurityCategoryIDs{c};
                    if iscell(CollateralIds)
                        fprintf('unwrapping collateral ids...')
                        CollateralIds = CollateralIds{:,:};
                        fprintf('out of cell.\n')
                    end

                    % If there is only one Collateral ID (scalar), we use
                    % == otherwise we use ismember
                    if isscalar(CollateralIds)
                        idx_inCurrentCollateralGroup = h0.L_Collateral_Type == CollateralIds;
                    else
                        idx_inCurrentCollateralGroup = ismember(h0.L_Collateral_Type,CollateralIds);
                    end
                    h0.CollateralGroups(idx_inCurrentCollateralGroup) = gridid;

                catch ME
                    assignin("base",'CollateralIds',CollateralIds)
                    assignin("base","h0",h0)
                    assignin("base","c",c)
                    rethrow(ME)
                end

            
            end
            
            % Add variable to dimensions cell
            dimensions.CollateralGroups.gridvar = 'CollateralGroups';
            dimensions.CollateralGroups.distvar = 'CollateralGroups';   

            % Identify NaN Collateral Groups
            diagnostics.idx_BadCollateralGroup = isnan(h0.CollateralGroups);



            % Industry Group REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Assign an industry group to each loan in the observations
            
            % Create 2-digit NAICS code
            h0.NAICS2 = floor(h0.B_NAICS_code ./ 10000);
            h0 = movevars(h0, "NAICS2", "Before", "B_NAICS_code");
            
            % Initialize
            h0.IndustryGroups = NaN(size(h0,1),1);
            h0 = movevars(h0, "IndustryGroups", "Before", 6);
            
            % Loop through each Industry category and assign its Id to the
            % appropriate loan observations
            indids = GRID.IndustryGroups.IndGrpID;
            for c = 1:length(indids)
            
                indid = indids(c);
                IndustryIds = GRID.IndustryGroups.NAICS2s{c};
                idx_inCurrentIndustryGroup = ismember(h0.NAICS2,IndustryIds);
                h0.IndustryGroups(idx_inCurrentIndustryGroup) = indid;
            
            end
            
            % Add variable to dimensions cell
            dimensions.IndustryGroups.gridvar = 'IndustryGroups';
            dimensions.IndustryGroups.distvar = 'IndustryGroups';   
            
            % Identify NaN Industry Groups
            diagnostics.idx_BadIndustryGroup = isnan(h0.IndustryGroups);



            % Geographies REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            % Assign a Geography ID to each loan. The Geography field is a
            % multi vector field.

            % First we get the location variables table (matches the
            % location name variables with the id variables), the
            % defGeographyTable function can return this table.
            [~,~,~,LocVarsTab] = defGeographyTable(DB.TaxonomyTabs.LocationDatabase);

            % Identify which variables (ID variables) are used in the GRID
            % to define geography
            idx_locIDVars = ismember(GRID.Geographies.Properties.VariableNames, LocVarsTab.LocIDVar);
            GRIDlocIDVars = GRID.Geographies.Properties.VariableNames(idx_locIDVars);

            % the observation data only has zip codes, so we need to match
            % each location by zipcode
            [ina_zips, locb_zips] = ismember(h0.B_Zipcode,DB.TaxonomyTabs.LocationDatabase.zip_numeric);
            geographies = NaN(size(h0,1),length(GRIDlocIDVars));
            geographies(ina_zips,:) = DB.TaxonomyTabs.LocationDatabase{locb_zips(ina_zips),GRIDlocIDVars};
            
            % Add geography variable to historical data table
            h0.Geographies = geographies;
            h0 = movevars(h0, "Geographies", "Before", 7);

            % Add variable to dimensions cell
            dimensions.Geographies.gridvar = 'Geographies';
            dimensions.Geographies.distvar = 'Geographies';
                        
            % Identify NaN Geographies (cant find zips)
            diagnostics.idx_BadGeographyGroup = isnan(any(h0.Geographies));

            % Remove Excluded Loans REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            idx_KEEP = all([diagnostics.idx_lagKeep,...
                diagnostics.idx_includeOrigination,...
                diagnostics.idx_index2Include],2);
            h1 = h0(idx_KEEP,:);



            % Combine by Pricing Decision REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            idx_PriceDecisionZero = h1.PriceDecisionID == 0;
            h2 = h1(~idx_PriceDecisionZero,:);
            diagnostics.PriceDecisionZero = h0(idx_PriceDecisionZero,:);
            
            
            OBSvarNames = {'FacilityType','Lag','RiskCategories','TermMonths','TermCategories','CollateralGroups',...
                'IndustryGroups','Geographies','LoanSize','LoanSizeGroup','NewOrRenewal','RateType','SPR'};
            OBS_FULL = h2(:,[{'PriceDecisionID'},OBSvarNames]);

            
            % Group by pricing decision, taking median of grouped variables. Then
            % remove the median_ prefix to the variable names.
            G_med = grpstats(OBS_FULL,"PriceDecisionID","median");
            G_med.Properties.VariableNames = strrep(G_med.Properties.VariableNames, "median_","");
            
            % Group by pricing decision, taking mode of grouped variables. Then remove 
            % the mode_ prefix to the variable names.
            G_mod = grpstats(OBS_FULL,"PriceDecisionID","mode");
            G_mod.Properties.VariableNames = strrep(G_mod.Properties.VariableNames, "mode_","");
            
            % Construct the Observations Table using mode for categorical variables and
            % median for numeric variables
            OBS = [G_med(:,{'PriceDecisionID','GroupCount','SPR'}),...
                G_mod(:,cellstr(char(GRID.Categoricals.Property(GRID.Categoricals.IsCat)))),...
                G_med(:,cellstr(char(GRID.Categoricals.Property(~GRID.Categoricals.IsCat))))];
            OBS.OBS_ID = [1:size(OBS,1)]';
            OBS = movevars(OBS, "OBS_ID", "Before", 1);

            % Remove any observations with NaN values
            %diagnostics.idx_OBSNaN = any(isnan(OBS{:,:}),2);
            diagnostics.idx_OBSNaN = isnan(OBS.SPR);
            OBS = OBS(~diagnostics.idx_OBSNaN,:);

            % Store information in a CLApopulatedGrid REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
            POPGRID = CLApopulatedGrid(GRID);
            POPGRID.OBS = OBS;
            POPGRID.dimensions = defDimensionsStruct(POPGRID.POPULATED_GRID);


        end
    end
end
##### SOURCE END #####
-->
</body>
</html>
